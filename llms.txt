Directory structure:
└── thevgergroup-potxkit/
    ├── AGENTS.md
    ├── README.md
    ├── LICENSE
    ├── pyproject.toml
    ├── poetry.lock
    ├── .gitignore
    ├── .pre-commit-config.yaml
    ├── assets/
    │   ├── app_icon.png
    │   ├── app_icon.pxd
    │   ├── logo.png
    │   └── logo.pxd
    ├── docs/
    │   ├── SDK.md
    │   ├── mcp.json
    │   ├── slide_tree.json
    │   ├── PRD/
    │   │   └── requirements.md
    │   └── use_cases/
    │       ├── gaps_plan.md
    │       └── use_cases.md
    ├── examples/
    │   ├── README.md
    │   ├── basic_edit.py
    │   ├── mapping.json
    │   ├── new_template.py
    │   ├── palette.json
    │   ├── palette_json.py
    │   ├── styles.json
    │   └── tree_summary.txt
    ├── mcpb/
    │   └── src/
    │       └── server.py
    ├── scripts/
    │   ├── build_mcpb.py
    │   ├── create_default_theme.py
    │   ├── generate_base_template.py
    │   └── install-hooks.sh
    ├── src/
    │   └── potxkit/
    │       ├── __init__.py
    │       ├── audit.py
    │       ├── auto_layout.py
    │       ├── cli.py
    │       ├── content_types.py
    │       ├── dump_tree.py
    │       ├── formatting.py
    │       ├── layout_ops.py
    │       ├── mcp_server.py
    │       ├── media.py
    │       ├── normalize.py
    │       ├── package.py
    │       ├── rels.py
    │       ├── resources.py
    │       ├── sanitize.py
    │       ├── slide_index.py
    │       ├── storage.py
    │       ├── template.py
    │       ├── theme.py
    │       ├── typography.py
    │       ├── validate.py
    │       └── data/
    │           ├── __init__.py
    │           └── base.potx
    ├── tests/
    │   ├── conftest.py
    │   ├── test_audit.py
    │   ├── test_auto_layout.py
    │   ├── test_dump_tree.py
    │   ├── test_formatting.py
    │   ├── test_mcp_server.py
    │   ├── test_normalize.py
    │   ├── test_prune_layouts.py
    │   ├── test_reindex_layouts.py
    │   ├── test_sanitize.py
    │   ├── test_theme.py
    │   └── test_typography.py
    ├── .githooks/
    │   └── pre-commit
    ├── .github/
    │   └── workflows/
    │       ├── lint.yml
    │       ├── publish.yml
    │       └── tests.yml
    └── .vscode/
        └── settings.json

================================================
FILE: README.md
================================================
![potxkit logo](https://raw.githubusercontent.com/thevgergroup/potxkit/main/assets/logo.png)

# potxkit

Make PowerPoint templates consistent without manual, slide-by-slide cleanup.

[![Install Claude Desktop](https://img.shields.io/badge/Claude%20Desktop-Install-blue)](https://github.com/thevgergroup/potxkit/releases/latest/download/potxkit.mcpb)
[![Add to Cursor](https://img.shields.io/badge/Cursor-Add%20to%20Cursor-black)](cursor://anysphere.cursor-deeplink/mcp/install?name=potxkit&config=eyJwb3R4a2l0Ijp7ImNvbW1hbmQiOiJ1dngiLCJhcmdzIjpbInBvdHhraXQiXX19)

## Links

- GitHub: https://github.com/thevgergroup/potxkit
- PyPI: https://pypi.org/project/potxkit/

## Why this exists

PowerPoint templates have been hard to understand and fix for decades. Most decks slowly drift as people paste content and override styles. Many PowerPoint libraries make this worse by embedding colors and fonts directly on each slide, which bypasses the slide master and makes the template effectively useless. potxkit fixes the root problem by moving formatting back into the theme, master, and layouts so the template stays in control.

## PowerPoint styling hierarchy

PowerPoint styling is layered:

1) **Theme**: global colors + fonts for the file.
2) **Slide master**: the base look for all slides.
3) **Layouts**: variations like “Title Slide,” “Section Header,” etc.
4) **Local overrides**: formatting applied directly on a slide or shape.

When local overrides are everywhere, layouts and the master stop controlling the look. potxkit shows you where formatting is coming from and lets you push it back into the master/layouts so the deck behaves like a real template again.

## Why potxkit + AI agents

Using a CLI to fix templates is powerful but not friendly. Running potxkit as an MCP server lets an AI agent apply the right sequence of audits and fixes for you—cleaning overrides, applying palettes, and standardizing layouts in minutes instead of hours.

- Audit where colors/fonts/backgrounds/images are coming from.
- Strip local overrides so layouts and masters drive the look.
- Apply a consistent palette mapping across slides.
- Set theme fonts, sizes, and layout images programmatically.
- Let agents orchestrate the workflow with plain-language instructions.

## What you can do

- Audit decks to see which slides override the master (colors, text, backgrounds, images).
- Normalize or strip local formatting so slides inherit from layouts/master.
- Create a layout from an existing slide (shapes/images included) and apply it across ranges.
- Apply palettes and font families across templates or decks.
- Reindex/prune layouts and validate OOXML structure.

## Choose your interface

### MCP server (recommended for agents)
Runs over stdio and exposes all commands as tools.

```bash
uvx potxkit
```

Example config (`docs/mcp.json`):

```json
{
  "mcpServers": {
    "potxkit": {
      "command": "uvx",
      "args": ["potxkit"]
    }
  }
}
```

### CLI (recommended for humans)

```bash
poetry run potxkit-cli --help
```

### SDK (recommended for developers)

```python
from potxkit import PotxTemplate

tpl = PotxTemplate.open("template.potx")
tpl.theme.colors.set_accent(1, "#1F6BFF")
tpl.theme.fonts.set_major("Aptos Display")
tpl.save("brand-template.potx")
```

## MCP client setup

potxkit runs as a local MCP server. Most clients accept this config:

```json
{
  "mcpServers": {
    "potxkit": {
      "command": "uvx",
      "args": ["potxkit"]
    }
  }
}
```

### One-click installs

- **Claude Desktop**: download `potxkit.mcpb` from GitHub releases and install via Settings -> Extensions -> Advanced Settings -> Install Extension.
  - Suggested release asset: https://github.com/thevgergroup/potxkit/releases/latest/download/potxkit.mcpb
- **Cursor**: Add to Cursor link:
  - cursor://anysphere.cursor-deeplink/mcp/install?name=potxkit&config=eyJwb3R4a2l0Ijp7ImNvbW1hbmQiOiJ1dngiLCJhcmdzIjpbInBvdHhraXQiXX19

### CLI or config installs

**Claude Code**

```bash
claude mcp add --transport stdio potxkit -- uvx potxkit
```

If you already installed the Claude Desktop extension, you can import it:

```bash
claude mcp add-from-claude-desktop
```

**Codex (OpenAI)**

```bash
codex mcp add potxkit -- uvx potxkit
```

Or add to `~/.codex/config.toml` (or project `.codex/config.toml`):

```toml
[mcp_servers.potxkit]
command = "uvx"
args = ["potxkit"]
```

**Gemini CLI**

Add to your project `.gemini/settings.json` under `mcpServers`:

```json
{
  "mcpServers": {
    "potxkit": {
      "command": "uvx",
      "args": ["potxkit"]
    }
  }
}
```

**Roo Code**

Add to `.roo/mcp.json` (project) or `mcp_settings.json` (global):

```json
{
  "mcpServers": {
    "potxkit": {
      "command": "uvx",
      "args": ["potxkit"]
    }
  }
}
```

### Maintainer release checklist (one-click installs)

- Tag a release (`vX.Y.Z`). GitHub Actions builds and uploads `potxkit.mcpb` using `scripts/build_mcpb.py`.
- For local builds: `python scripts/build_mcpb.py --version X.Y.Z`.
- If the MCP command or args change, update the Cursor deep link config (base64 of `{\"potxkit\":{\"command\":\"uvx\",\"args\":[\"potxkit\"]}}`).
- Click both install links to verify they still open correctly.

## Common workflows

Audit a deck to find local formatting:

```bash
poetry run potxkit-cli audit path/to/template.pptx --summary --group-by p,b,l
```

Create a new layout from slide 7 and apply it to a range:

```bash
poetry run potxkit-cli make-layout --from-slide 7 --name "Layout Bob" \
  --assign-slides 1-7,9-10 output.pptx --input path/to/template.pptx
```

Strip inline colors/fonts so slides inherit from layouts/master:

```bash
poetry run potxkit-cli set-slide --slides 1-11 --palette-none --fonts-none \
  output.pptx --input path/to/template.pptx
```

Normalize a deck to a palette mapping:

```bash
poetry run potxkit-cli normalize examples/mapping.json output.pptx \
  --input path/to/template.pptx --slides 1,3-5
```

Update theme colors, fonts, and friendly names:

```bash
poetry run potxkit-cli set-colors output.potx --input path/to/template.potx \
  --accent1 #1F6BFF --hlink #1F6BFF
poetry run potxkit-cli set-fonts output.potx --input path/to/template.potx \
  --major "Aptos Display" --minor "Aptos"
poetry run potxkit-cli set-theme-names output.potx --input path/to/template.potx \
  --theme "Code Janitor" --colors "Code Janitor Colors" --fonts "Code Janitor Fonts"
```

## Images, palettes, fonts, and sizes

Add a background image to a layout:

```bash
poetry run potxkit-cli set-layout-bg --layout "Layout Bob" \
  --image path/to/hero.png output.pptx --input path/to/template.pptx
```

Add an image layer (x/y/w/h in inches unless `--units emu`):

```bash
poetry run potxkit-cli set-layout-image --layout "Layout Bob" \
  --image path/to/overlay.png --x 1 --y 1 --w 3 --h 2 \
  output.pptx --input path/to/template.pptx
```

Apply a palette mapping:

```bash
poetry run potxkit-cli normalize examples/mapping.json output.pptx \
  --input path/to/template.pptx --slides 1,3-5
```

Full palette file example (for `apply-palette`):

```json
{
  "dark1": "#FFFFFF",
  "light1": "#0B0B0E",
  "dark2": "#2C2C34",
  "light2": "#E9ECF2",
  "accent1": "#1F6BFF",
  "accent2": "#E0328C",
  "accent3": "#F6A225",
  "accent4": "#6B3AF6",
  "accent5": "#38D3FF",
  "accent6": "#FF4D6D",
  "hlink": "#1F6BFF",
  "folHlink": "#C0186B",
  "majorFont": "Aptos Display",
  "minorFont": "Aptos"
}
```

What the keys mean (simple):

- `dark1`, `light1`, `dark2`, `light2`: base theme colors PowerPoint uses for text/backgrounds.
- `accent1`–`accent6`: the six accent colors used for charts, shapes, and theme color picks.
- `hlink`, `folHlink`: hyperlink and followed‑link colors.
- `majorFont`, `minorFont`: theme font families (major = headings, minor = body).

```bash
poetry run potxkit-cli apply-palette examples/palette.json output.potx \
  --input path/to/template.potx
```

Set fonts:

```bash
poetry run potxkit-cli set-fonts output.potx --input path/to/template.potx \
  --major "Aptos Display" --minor "Aptos"
```

Set text sizes (points) and bold/regular for a layout:

```bash
poetry run potxkit-cli set-text-styles --layout "Layout Bob" \
  --title-size 30 --title-bold --body-size 20 --body-regular \
  output.pptx --input path/to/template.pptx
```

## Examples

See `examples/README.md` for step-by-step walkthroughs and the reason each command exists.

## SDK documentation

Full API reference in `docs/SDK.md`.

## Project layout

- `src/potxkit/`: library + MCP/CLI implementation
- `examples/`: runnable scripts and sample inputs
- `docs/`: reference docs and MCP config
- `tests/`: pytest suite

## Notes and limitations

- potxkit edits theme data and slide/layout formatting. It does not render slides.
- For complex branded layouts, start from a PowerPoint-authored `.potx` and use potxkit to standardize themes and remove local overrides.

## License

MIT License. See `LICENSE`.



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2026 Patrick O'Leary The VGER Group

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: pyproject.toml
================================================
[project]
name = "potxkit"
dynamic = ["version"]
description = "POTX theme editor"
authors = [
    {name = "patrick o'leary",email = "pjaol@pjaol.com"}
]
license = {file = "LICENSE"}
readme = "README.md"
requires-python = ">=3.11,<4.0"
dependencies = [
    "fsspec>=2024.2.0",
    "fastmcp>=2.0,<3",
]

[project.urls]
Homepage = "https://github.com/thevgergroup/potxkit"
Repository = "https://github.com/thevgergroup/potxkit"
Issues = "https://github.com/thevgergroup/potxkit/issues"
Documentation = "https://github.com/thevgergroup/potxkit/blob/main/docs/SDK.md"
PyPI = "https://pypi.org/project/potxkit/"

[project.scripts]
potxkit = "potxkit.mcp_server:main"
potxkit-cli = "potxkit.cli:main"

[tool.poetry]
packages = [{include = "potxkit", from = "src"}]
include = ["src/potxkit/data/base.potx"]
version = "0.0.0"

[tool.poetry.requires-plugins]
poetry-dynamic-versioning = {version = ">=1.9.1,<2.0.0", extras = ["plugin"]}

[tool.poetry-dynamic-versioning]
enable = true

[tool.poetry.group.dev.dependencies]
black = "^24.10.0"
pre-commit = "^3.8.0"
pytest = "^8.2.0"
pytest-asyncio = "^0.25.3"
python-pptx = "^0.6.23"
ruff = "^0.7.3"
vulture = "^2.11"

[tool.pytest.ini_options]
testpaths = ["tests"]
asyncio_mode = "auto"

[tool.black]
line-length = 88
target-version = ["py311"]

[tool.ruff]
line-length = 88
target-version = "py311"

[tool.ruff.lint]
select = ["E", "F", "I"]
ignore = ["E501"]

[tool.vulture]
min_confidence = 80
paths = ["src/potxkit"]
exclude = ["*/data/*"]


[build-system]
requires = [
    "poetry-core>=2.0.0,<3.0.0",
    "poetry-dynamic-versioning>=1.9.1,<2.0.0",
]
build-backend = "poetry_dynamic_versioning.backend"



================================================
FILE: .pre-commit-config.yaml
================================================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.7.3
    hooks:
      - id: ruff
        args: ["--fix", "--exit-non-zero-on-fix"]
  - repo: https://github.com/psf/black
    rev: 24.10.0
    hooks:
      - id: black
  - repo: https://github.com/jendrikseipp/vulture
    rev: v2.11
    hooks:
      - id: vulture
        args: ["src/potxkit", "--min-confidence", "80"]



================================================
FILE: examples/README.md
================================================
# Examples

These examples are meant to be copy/paste friendly and explain what each command accomplishes so you can adapt them to real decks.

## Setup

```bash
poetry install
```

## MCP server

Use this if you want an agent to call potxkit tools directly:

```bash
uvx potxkit
```

Example config (`docs/mcp.json`):

```json
{
  "mcpServers": {
    "potxkit": {
      "command": "uvx",
      "args": ["potxkit"]
    }
  }
}
```

## Scripted workflows

### Edit an existing theme

```bash
poetry run python examples/basic_edit.py path/to/input.potx path/to/output.potx
```

Edits accent colors and font families in a `.potx`.

### Create a fresh template

```bash
poetry run python examples/new_template.py path/to/output.potx
```

Creates a new theme from the bundled base.

### Apply a palette.json

```bash
poetry run python examples/palette_json.py examples/palette.json path/to/output.potx
```

Applies a palette file (use `palette-template` to generate one).

## CLI workflows (with intent)

### Inspect a deck or template

```bash
poetry run potxkit-cli info path/to/template.potx
poetry run potxkit-cli dump-theme path/to/template.potx --pretty
```

Use these to confirm current theme colors and fonts before changing anything.

### Audit where formatting is coming from

```bash
poetry run potxkit-cli audit path/to/template.pptx --summary --group-by p,b,l
poetry run potxkit-cli dump-tree path/to/template.pptx --grouped --text --summary --output tree_summary.txt
```

`audit` summarizes local overrides; `dump-tree` shows master/layout/slide sources.

### Standardize palette and fonts

```bash
poetry run potxkit-cli set-colors output.potx --input path/to/template.potx --accent1 #1F6BFF
poetry run potxkit-cli set-fonts output.potx --input path/to/template.potx --major "Aptos Display"
```

Use for simple theme updates without touching layouts.

### Add layout background or image layers

```bash
poetry run potxkit-cli set-layout-bg --layout "Layout Bob" \
  --image path/to/hero.png output.pptx --input path/to/template.pptx
```

```bash
poetry run potxkit-cli set-layout-image --layout "Layout Bob" \
  --image path/to/overlay.png --x 1 --y 1 --w 3 --h 2 \
  output.pptx --input path/to/template.pptx
```

Use when you want layouts to carry the visuals instead of individual slides.

### Set text sizes and weights

```bash
poetry run potxkit-cli set-text-styles --layout "Layout Bob" \
  --title-size 30 --title-bold --body-size 20 --body-regular \
  output.pptx --input path/to/template.pptx
```

Use to keep title/body sizes consistent across slides.

### Create a layout from a slide

```bash
poetry run potxkit-cli make-layout --from-slide 7 --name "Layout Bob" \
  --assign-slides 1-7,9-10 output.pptx --input path/to/template.pptx
```

Copies shapes/images from slide 7 into a new layout and assigns it to a slide range.

### Remove local overrides (let layouts drive style)

```bash
poetry run potxkit-cli set-slide --slides 1-11 --palette-none --fonts-none \
  output.pptx --input path/to/template.pptx
```

Use when the deck has heavy inline formatting and you want inheritance from layouts/master.

### Normalize mixed palettes

```bash
poetry run potxkit-cli normalize examples/mapping.json output.pptx \
  --input path/to/template.pptx --slides 1,3-5
```

Maps arbitrary slide colors to a standard theme palette.



================================================
FILE: examples/basic_edit.py
================================================
from __future__ import annotations

import sys

from potxkit import PotxTemplate


def main() -> int:
    if len(sys.argv) != 3:
        print("Usage: basic_edit.py input.potx output.potx")
        return 1

    input_path, output_path = sys.argv[1:3]
    tpl = PotxTemplate.open(input_path)

    tpl.theme.colors.set_accent(1, "#1F6BFF")
    tpl.theme.colors.set_accent(2, "#E0328C")
    tpl.theme.colors.set_hyperlink("#1F6BFF")
    tpl.theme.fonts.set_major("Aptos Display")
    tpl.theme.fonts.set_minor("Aptos")

    tpl.save(output_path)
    print(f"Wrote {output_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())



================================================
FILE: examples/mapping.json
================================================
{
  "#0D0D14": "dark1",
  "#1A1A2E": "dark2",
  "#252538": "dark2",
  "#FFFFFF": "light1",
  "#8A8A9A": "light2",
  "#00D9FF": "accent1",
  "#FF4757": "accent2"
}



================================================
FILE: examples/new_template.py
================================================
from __future__ import annotations

import sys

from potxkit import PotxTemplate


def main() -> int:
    if len(sys.argv) != 2:
        print("Usage: new_template.py output.potx")
        return 1

    output_path = sys.argv[1]
    tpl = PotxTemplate.new()

    tpl.theme.colors.set_dark1("#0B0B0E")
    tpl.theme.colors.set_light1("#FFFFFF")
    tpl.theme.colors.set_accent(1, "#1F6BFF")
    tpl.theme.colors.set_accent(2, "#E0328C")
    tpl.theme.fonts.set_major("Aptos Display")
    tpl.theme.fonts.set_minor("Aptos")

    tpl.save(output_path)
    print(f"Wrote {output_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())



================================================
FILE: examples/palette.json
================================================
{
  "dark1": "#FFFFFF",
  "light1": "#0B0B0E",
  "dark2": "#2C2C34",
  "light2": "#E9ECF2",
  "accent1": "#1F6BFF",
  "accent2": "#E0328C",
  "accent3": "#F6A225",
  "accent4": "#6B3AF6",
  "accent5": "#38D3FF",
  "accent6": "#FF4D6D",
  "hlink": "#1F6BFF",
  "folHlink": "#C0186B",
  "majorFont": "Aptos Display",
  "minorFont": "Aptos"
}



================================================
FILE: examples/palette_json.py
================================================
from __future__ import annotations

import json
import sys

from potxkit import PotxTemplate


def main() -> int:
    if len(sys.argv) != 3:
        print("Usage: palette_json.py palette.json output.potx")
        return 1

    palette_path, output_path = sys.argv[1:3]
    palette = json.loads(open(palette_path, "r", encoding="utf-8").read())

    tpl = PotxTemplate.new()
    tpl.theme.colors.set_dark1(palette["dark1"])
    tpl.theme.colors.set_light1(palette["light1"])
    tpl.theme.colors.set_dark2(palette["dark2"])
    tpl.theme.colors.set_light2(palette["light2"])
    tpl.theme.colors.set_accent(1, palette["accent1"])
    tpl.theme.colors.set_accent(2, palette["accent2"])
    tpl.theme.colors.set_accent(3, palette["accent3"])
    tpl.theme.colors.set_accent(4, palette["accent4"])
    tpl.theme.colors.set_accent(5, palette["accent5"])
    tpl.theme.colors.set_accent(6, palette["accent6"])
    tpl.theme.colors.set_hyperlink(palette["hlink"])
    tpl.theme.colors.set_followed_hyperlink(palette["folHlink"])
    tpl.theme.fonts.set_major(palette["majorFont"])
    tpl.theme.fonts.set_minor(palette["minorFont"])

    tpl.save(output_path)
    print(f"Wrote {output_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())



================================================
FILE: examples/styles.json
================================================
{
  "title": {
    "size": 30,
    "bold": true
  },
  "body": {
    "size": 20,
    "bold": false
  }
}



================================================
FILE: examples/tree_summary.txt
================================================
slide 1:
  slideMaster: bg=scheme(lt1) fills(hard=0, theme=3) text(hard=0, theme=2) fonts=Aptos(6) sizes={18, 24} clrMap=yes
  slideLayout: bg=none fills(hard=0, theme=2) text(hard=0, theme=1) fonts=Aptos(4) sizes={18} clrMap=yes
  local: bg=srgb(#F5F2EE) fills(hard=2, theme=1) text(hard=1, theme=0) fonts=Aptos(3) sizes={18, 24} clrMap=override



================================================
FILE: mcpb/src/server.py
================================================
#!/usr/bin/env python3
"""MCP entry point for potxkit (uv runtime)."""

from potxkit.mcp_server import main

if __name__ == "__main__":
    main()



================================================
FILE: scripts/build_mcpb.py
================================================
#!/usr/bin/env python3
"""Build the potxkit MCP bundle (.mcpb)."""

from __future__ import annotations

import argparse
import json
import os
import shutil
import subprocess
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
TEMPLATE_DIR = ROOT / "mcpb"
SERVER_SRC = TEMPLATE_DIR / "src" / "server.py"


def _resolve_version(explicit: str | None) -> str:
    if explicit:
        return explicit.lstrip("v")
    env_version = os.getenv("POTXKIT_VERSION")
    if env_version:
        return env_version.lstrip("v")
    ref_name = os.getenv("GITHUB_REF_NAME")
    if ref_name:
        return ref_name.lstrip("v")
    try:
        result = subprocess.run(
            ["git", "describe", "--tags", "--abbrev=0"],
            check=True,
            capture_output=True,
            text=True,
            cwd=ROOT,
        )
        return result.stdout.strip().lstrip("v")
    except subprocess.CalledProcessError as exc:
        raise RuntimeError("Unable to determine version; pass --version.") from exc


def _write_manifest(dest: Path, version: str) -> None:
    manifest = {
        "manifest_version": "0.4",
        "name": "potxkit",
        "display_name": "potxkit",
        "version": version,
        "description": "PowerPoint theme and template fixer for MCP",
        "author": {
            "name": "Patrick O'Leary",
        },
        "server": {
            "type": "uv",
            "entry_point": "src/server.py",
            "mcp_config": {
                "command": "uv",
                "args": ["run", "${__dirname}/src/server.py"],
            },
        },
        "compatibility": {
            "platforms": ["darwin", "linux", "win32"],
            "runtimes": {"python": ">=3.11"},
        },
        "keywords": ["powerpoint", "templates", "mcp", "pptx", "potx"],
        "license": "MIT",
    }
    dest.write_text(json.dumps(manifest, indent=2) + "\n")


def _write_pyproject(dest: Path, version: str) -> None:
    content = (
        "[project]\n"
        'name = "potxkit-mcp"\n'
        f'version = "{version}"\n'
        'description = "potxkit MCP server"\n'
        'requires-python = ">=3.11"\n'
        "dependencies = [\n"
        f'    "potxkit=={version}",\n'
        "]\n"
    )
    dest.write_text(content)


def _ensure_mcpb_cli() -> None:
    if shutil.which("mcpb"):
        return
    raise RuntimeError(
        "mcpb CLI not found. Install with: npm install -g @anthropic-ai/mcpb"
    )


def build_bundle(output: Path, version: str) -> None:
    workdir = output.parent / "mcpb"
    if workdir.exists():
        shutil.rmtree(workdir)
    (workdir / "src").mkdir(parents=True, exist_ok=True)

    shutil.copy2(SERVER_SRC, workdir / "src" / "server.py")
    _write_manifest(workdir / "manifest.json", version)
    _write_pyproject(workdir / "pyproject.toml", version)

    _ensure_mcpb_cli()
    output.parent.mkdir(parents=True, exist_ok=True)
    subprocess.run(["mcpb", "pack", str(workdir), str(output)], check=True)


def main() -> None:
    parser = argparse.ArgumentParser(description="Build potxkit MCP bundle")
    parser.add_argument("--version", help="Bundle version (e.g., 0.2.1)")
    parser.add_argument(
        "--output",
        default=str(ROOT / "dist" / "potxkit.mcpb"),
        help="Output .mcpb path",
    )
    args = parser.parse_args()

    version = _resolve_version(args.version)
    output = Path(args.output)
    build_bundle(output, version)
    print(f"Built {output}")


if __name__ == "__main__":
    main()



================================================
FILE: scripts/create_default_theme.py
================================================
from __future__ import annotations

from pathlib import Path

from potxkit import PotxTemplate

PALETTE = {
    "dark1": "#FFFFFF",
    "light1": "#0B0B0E",
    "dark2": "#2C2C34",
    "light2": "#E9ECF2",
    "accent1": "#1F6BFF",
    "accent2": "#E0328C",
    "accent3": "#F6A225",
    "accent4": "#6B3AF6",
    "accent5": "#38D3FF",
    "accent6": "#FF4D6D",
    "hlink": "#1F6BFF",
    "folHlink": "#C0186B",
}


def main() -> None:
    tpl = PotxTemplate.new()
    tpl.theme.colors.set_dark1(PALETTE["dark1"])
    tpl.theme.colors.set_light1(PALETTE["light1"])
    tpl.theme.colors.set_dark2(PALETTE["dark2"])
    tpl.theme.colors.set_light2(PALETTE["light2"])
    tpl.theme.colors.set_accent(1, PALETTE["accent1"])
    tpl.theme.colors.set_accent(2, PALETTE["accent2"])
    tpl.theme.colors.set_accent(3, PALETTE["accent3"])
    tpl.theme.colors.set_accent(4, PALETTE["accent4"])
    tpl.theme.colors.set_accent(5, PALETTE["accent5"])
    tpl.theme.colors.set_accent(6, PALETTE["accent6"])
    tpl.theme.colors.set_hyperlink(PALETTE["hlink"])
    tpl.theme.colors.set_followed_hyperlink(PALETTE["folHlink"])

    tpl.theme.fonts.set_major("Aptos Display")
    tpl.theme.fonts.set_minor("Aptos")

    out_path = Path("templates/default-dark.potx")
    out_path.parent.mkdir(parents=True, exist_ok=True)
    tpl.save(str(out_path))


if __name__ == "__main__":
    main()



================================================
FILE: scripts/generate_base_template.py
================================================
from __future__ import annotations

import tempfile
import xml.etree.ElementTree as ET
from pathlib import Path

from pptx import Presentation

from potxkit.package import OOXMLPackage

CT_NS = "http://schemas.openxmlformats.org/package/2006/content-types"
P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
PRESENTATION_PART = "/ppt/presentation.xml"
TEMPLATE_CONTENT_TYPE = (
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml"
)
ET.register_namespace("p", P_NS)
ET.register_namespace("a", A_NS)


def main() -> None:
    out_path = Path("src/potxkit/data/base.potx")
    out_path.parent.mkdir(parents=True, exist_ok=True)

    with tempfile.TemporaryDirectory() as tmp_dir:
        tmp_pptx = Path(tmp_dir) / "base.pptx"
        Presentation().save(tmp_pptx)
        data = tmp_pptx.read_bytes()

    pkg = OOXMLPackage(data)
    pkg.write_part(
        "[Content_Types].xml",
        _update_content_types(pkg.read_part("[Content_Types].xml")),
    )
    pkg.write_part(
        "ppt/slideMasters/slideMaster1.xml",
        _apply_master_background(pkg.read_part("ppt/slideMasters/slideMaster1.xml")),
    )
    out_path.write_bytes(pkg.save_bytes())


def _update_content_types(xml_bytes: bytes) -> bytes:
    root = ET.fromstring(xml_bytes)
    for override in root.findall(f"{{{CT_NS}}}Override"):
        if override.attrib.get("PartName") == PRESENTATION_PART:
            override.set("ContentType", TEMPLATE_CONTENT_TYPE)
            break
    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


def _apply_master_background(xml_bytes: bytes) -> bytes:
    root = ET.fromstring(xml_bytes)
    c_sld = root.find(f"{{{P_NS}}}cSld")
    if c_sld is None:
        return xml_bytes

    bg = c_sld.find(f"{{{P_NS}}}bg")
    if bg is None:
        bg = ET.SubElement(c_sld, f"{{{P_NS}}}bg")
    for child in list(bg):
        bg.remove(child)

    bg_pr = ET.SubElement(bg, f"{{{P_NS}}}bgPr")
    grad = ET.SubElement(bg_pr, f"{{{A_NS}}}gradFill", {"rotWithShape": "1"})
    gs_list = ET.SubElement(grad, f"{{{A_NS}}}gsLst")

    stops = [
        (0, "0B0B0E"),
        (55000, "0B2E66"),
        (100000, "4B0F6B"),
    ]
    for pos, color in stops:
        gs = ET.SubElement(gs_list, f"{{{A_NS}}}gs", {"pos": str(pos)})
        ET.SubElement(gs, f"{{{A_NS}}}srgbClr", {"val": color})

    ET.SubElement(grad, f"{{{A_NS}}}lin", {"ang": "5400000", "scaled": "0"})
    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


if __name__ == "__main__":
    main()



================================================
FILE: scripts/install-hooks.sh
================================================
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR=$(cd "$(dirname "$0")/.." && pwd)
git -C "$ROOT_DIR" config core.hooksPath .githooks
if command -v pre-commit >/dev/null 2>&1; then
  # pre-commit refuses to install when core.hooksPath is set; our .githooks/pre-commit
  # script runs pre-commit directly. We still warm the environments here.
  (cd "$ROOT_DIR" && pre-commit run --hook-stage pre-commit --all-files)
else
  echo "pre-commit not found; install it with 'poetry run pip install pre-commit' or 'pip install pre-commit'."
fi
echo "Git hooks installed (core.hooksPath=.githooks)"



================================================
FILE: src/potxkit/__init__.py
================================================
"""POTX theme editing toolkit."""

from .template import PotxTemplate

__all__ = ["PotxTemplate"]
__version__ = "0.1.0"



================================================
FILE: src/potxkit/audit.py
================================================
from __future__ import annotations

import posixpath
import xml.etree.ElementTree as ET
from collections import Counter
from dataclasses import dataclass
from typing import Any, Iterable

from .package import OOXMLPackage
from .rels import parse_relationships, rels_part_for
from .slide_index import slide_parts_in_order
from .typography import extract_text_style_stats

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"

NS = {"p": P_NS, "a": A_NS}


@dataclass
class AuditReport:
    slides_total: int
    slides_audited: int
    per_slide: dict[int, dict[str, Any]]
    masters: dict[str, dict[str, Any]]
    layouts: dict[str, dict[str, Any]]
    groups: list[dict[str, Any]]
    theme: dict[str, str] | None
    group_by: list[str]


def audit_package(
    pkg: OOXMLPackage,
    slide_numbers: set[int] | None = None,
    group_by: Iterable[str] | None = None,
) -> AuditReport:
    slide_parts = slide_parts_in_order(pkg)
    per_slide: dict[int, dict[str, Any]] = {}
    masters = _summarize_parts(pkg, "ppt/slideMasters/")
    layouts = _summarize_parts(pkg, "ppt/slideLayouts/")
    group_by_list = _normalize_group_by(group_by)

    layout_master = _layout_master_map(pkg)

    for index, slide_part in enumerate(slide_parts, start=1):
        if slide_numbers and index not in slide_numbers:
            continue
        root = ET.fromstring(pkg.read_part(slide_part))
        slide_layout = _slide_layout_part(pkg, slide_part)
        master_part = layout_master.get(slide_layout) if slide_layout else None

        per_slide[index] = {
            "slide_part": slide_part,
            "layout_part": slide_layout,
            "master_part": master_part,
            "color_counts": _color_counts(root),
            "shape_colors": _shape_color_counts(root),
            "text_colors": _text_color_counts(root),
            "text_styles": _text_style_summary(root),
            "has_clrMapOvr": root.find(".//p:clrMapOvr", NS) is not None,
            "background": _background_flags(root),
            "fills": _fill_counts(root),
            "pictures": len(root.findall(".//p:pic", NS)),
            "top_srgb": _top_srgb(root),
        }

    return AuditReport(
        slides_total=len(slide_parts),
        slides_audited=len(per_slide),
        per_slide=per_slide,
        masters=masters,
        layouts=layouts,
        groups=_group_slides(per_slide, group_by_list),
        theme=_theme_summary(pkg),
        group_by=group_by_list,
    )


def _color_counts(root: ET.Element) -> dict[str, int]:
    return {
        "srgb": len(root.findall(".//a:srgbClr", NS)),
        "scheme": len(root.findall(".//a:schemeClr", NS)),
        "sysclr": len(root.findall(".//a:sysClr", NS)),
    }


def _fill_counts(root: ET.Element) -> dict[str, int]:
    return {
        "solid": len(root.findall(".//a:solidFill", NS)),
        "grad": len(root.findall(".//a:gradFill", NS)),
        "blip": len(root.findall(".//a:blipFill", NS)),
    }


def _shape_color_counts(root: ET.Element) -> dict[str, int]:
    return {
        "srgb": len(root.findall(".//p:spPr//a:srgbClr", NS)),
        "scheme": len(root.findall(".//p:spPr//a:schemeClr", NS)),
        "sysclr": len(root.findall(".//p:spPr//a:sysClr", NS)),
    }


def _text_color_counts(root: ET.Element) -> dict[str, int]:
    return {
        "srgb": len(
            root.findall(".//a:rPr//a:srgbClr", NS)
            + root.findall(".//a:defRPr//a:srgbClr", NS)
            + root.findall(".//a:lstStyle//a:srgbClr", NS)
            + root.findall(".//a:buClr//a:srgbClr", NS)
        ),
        "scheme": len(
            root.findall(".//a:rPr//a:schemeClr", NS)
            + root.findall(".//a:defRPr//a:schemeClr", NS)
            + root.findall(".//a:lstStyle//a:schemeClr", NS)
            + root.findall(".//a:buClr//a:schemeClr", NS)
        ),
        "sysclr": len(
            root.findall(".//a:rPr//a:sysClr", NS)
            + root.findall(".//a:defRPr//a:sysClr", NS)
            + root.findall(".//a:lstStyle//a:sysClr", NS)
            + root.findall(".//a:buClr//a:sysClr", NS)
        ),
    }


def _text_style_summary(root: ET.Element) -> dict[str, Any]:
    stats = extract_text_style_stats(root)
    size_counter = Counter(
        {int(k): v for k, v in stats.size_counts.items() if str(k).isdigit()}
    )
    bold_counter = Counter(stats.bold_counts)
    sizes = [
        {"pt": size / 100, "count": count}
        for size, count in size_counter.most_common(5)
    ]
    return {
        "top_sizes": sizes,
        "bold": dict(bold_counter),
    }


def _background_flags(root: ET.Element) -> dict[str, bool]:
    bg = root.find("p:cSld/p:bg", NS)
    bg_pr = bg.find("p:bgPr", NS) if bg is not None else None
    bg_ref = bg.find("p:bgRef", NS) if bg is not None else None

    return {
        "bg_ref": bg_ref is not None,
        "bg_blip": bg_pr is not None and bg_pr.find("a:blipFill", NS) is not None,
        "bg_grad": bg_pr is not None and bg_pr.find("a:gradFill", NS) is not None,
        "bg_solid": bg_pr is not None and bg_pr.find("a:solidFill", NS) is not None,
    }


def _top_srgb(root: ET.Element, limit: int = 5) -> list[dict[str, int]]:
    values = [
        node.attrib.get("val", "").upper() for node in root.findall(".//a:srgbClr", NS)
    ]
    values = [val for val in values if val]
    counter = Counter(values)
    return [
        {"value": color, "count": count} for color, count in counter.most_common(limit)
    ]


def _slide_layout_part(pkg: OOXMLPackage, slide_part: str) -> str | None:
    rels_part = rels_part_for(slide_part)
    if not pkg.has_part(rels_part):
        return None
    relationships = parse_relationships(pkg.read_part(rels_part))
    for rel in relationships:
        if rel.type.endswith("/slideLayout"):
            return _resolve_target(posixpath.dirname(slide_part), rel.target)
    return None


def _layout_master_map(pkg: OOXMLPackage) -> dict[str, str]:
    mapping: dict[str, str] = {}
    for part in pkg.list_parts():
        if not part.startswith("ppt/slideLayouts/") or not part.endswith(".xml"):
            continue
        rels_part = rels_part_for(part)
        if not pkg.has_part(rels_part):
            continue
        relationships = parse_relationships(pkg.read_part(rels_part))
        for rel in relationships:
            if rel.type.endswith("/slideMaster"):
                mapping[part] = _resolve_target(posixpath.dirname(part), rel.target)
                break
    return mapping


def _summarize_parts(pkg: OOXMLPackage, prefix: str) -> dict[str, dict[str, Any]]:
    summary: dict[str, dict[str, Any]] = {}
    for part in pkg.list_parts():
        if not part.startswith(prefix) or not part.endswith(".xml"):
            continue
        root = ET.fromstring(pkg.read_part(part))
        summary[part] = {
            "color_counts": _color_counts(root),
            "shape_colors": _shape_color_counts(root),
            "text_colors": _text_color_counts(root),
            "fills": _fill_counts(root),
            "pictures": len(root.findall(".//p:pic", NS)),
            "top_srgb": _top_srgb(root),
            "has_clrMap": root.find(".//p:clrMap", NS) is not None,
            "has_clrMapOvr": root.find(".//p:clrMapOvr", NS) is not None,
        }
    return summary


def _group_slides(
    per_slide: dict[int, dict[str, Any]], group_by: list[str]
) -> list[dict[str, Any]]:
    groups: dict[tuple[object, ...], dict[str, Any]] = {}
    for slide_num, data in per_slide.items():
        palette = tuple(entry["value"] for entry in data.get("top_srgb", []))
        key_parts: list[object] = []
        if "l" in group_by:
            key_parts.append(data.get("layout_part"))
            key_parts.append(data.get("master_part"))
        if "b" in group_by:
            key_parts.append(_background_signature(data))
        if "p" in group_by:
            key_parts.append(palette)
        key = tuple(key_parts)
        group = groups.setdefault(
            key,
            {
                "layout_part": data.get("layout_part"),
                "master_part": data.get("master_part"),
                "background": _background_signature(data),
                "palette": list(palette),
                "slides": [],
                "hardcoded_total": 0,
                "text_srgb_total": 0,
                "shape_srgb_total": 0,
                "clrMapOvr_slides": 0,
                "image_slides": 0,
                "custom_bg_slides": 0,
            },
        )
        group["slides"].append(slide_num)
        counts = data["color_counts"]
        text_counts = data["text_colors"]
        shape_counts = data["shape_colors"]
        fills = data["fills"]
        bg = data["background"]

        group["hardcoded_total"] += counts["srgb"] + counts["sysclr"]
        group["text_srgb_total"] += text_counts["srgb"]
        group["shape_srgb_total"] += shape_counts["srgb"]
        if data.get("has_clrMapOvr"):
            group["clrMapOvr_slides"] += 1
        if data.get("pictures") or fills["blip"]:
            group["image_slides"] += 1
        if bg["bg_blip"] or bg["bg_grad"] or bg["bg_solid"] or bg["bg_ref"]:
            group["custom_bg_slides"] += 1

    for group in groups.values():
        group["slides"].sort()
    return list(groups.values())


def _background_signature(data: dict[str, Any]) -> str:
    bg = data.get("background", {})
    flags = []
    if bg.get("bg_blip"):
        flags.append("blip")
    if bg.get("bg_grad"):
        flags.append("grad")
    if bg.get("bg_solid"):
        flags.append("solid")
    if bg.get("bg_ref"):
        flags.append("ref")
    return "+".join(flags) if flags else "none"


def _normalize_group_by(value: Iterable[str] | None) -> list[str]:
    if value is None:
        return ["p", "l"]
    selected = []
    for token in value:
        if token not in {"p", "b", "l"}:
            raise ValueError(f"Invalid group-by option: {token}")
        if token not in selected:
            selected.append(token)
    return selected


def _theme_summary(pkg: OOXMLPackage) -> dict[str, str] | None:
    theme_parts = [
        part
        for part in pkg.list_parts()
        if part.startswith("ppt/theme/") and part.endswith(".xml")
    ]
    if not theme_parts:
        return None
    non_override = [part for part in theme_parts if "themeOverride" not in part]
    theme_part = sorted(non_override or theme_parts)[0]
    root = ET.fromstring(pkg.read_part(theme_part))
    theme_elements = root.find("a:themeElements", NS)
    clr_scheme = (
        theme_elements.find("a:clrScheme", NS) if theme_elements is not None else None
    )
    font_scheme = (
        theme_elements.find("a:fontScheme", NS) if theme_elements is not None else None
    )
    return {
        "part": theme_part,
        "theme_name": root.attrib.get("name", ""),
        "color_scheme_name": (
            clr_scheme.attrib.get("name", "") if clr_scheme is not None else ""
        ),
        "font_scheme_name": (
            font_scheme.attrib.get("name", "") if font_scheme is not None else ""
        ),
    }


def _resolve_target(base_dir: str, target: str) -> str:
    if target.startswith("/"):
        return target[1:]
    return posixpath.normpath(posixpath.join(base_dir, target))



================================================
FILE: src/potxkit/auto_layout.py
================================================
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable

from .audit import audit_package
from .layout_ops import (
    apply_palette_to_part,
    assign_slides_to_layout,
    make_layout_from_slide,
    strip_colors_from_part,
    strip_fonts_from_part,
)
from .package import OOXMLPackage


@dataclass
class AutoLayoutResult:
    created_layouts: list[str]
    group_count: int


def auto_layout(
    pkg: OOXMLPackage,
    *,
    group_by: Iterable[str] | None = None,
    prefix: str = "Auto Layout",
    master_index: int = 1,
    assign: bool = True,
    strip_colors: bool = False,
    strip_fonts: bool = False,
    palette: dict[str, str] | None = None,
) -> AutoLayoutResult:
    report = audit_package(pkg, group_by=group_by)
    created: list[str] = []

    for idx, group in enumerate(report.groups, start=1):
        slides = group.get("slides", [])
        if not slides:
            continue
        layout_name = f"{prefix} {idx}"
        layout_part = make_layout_from_slide(
            pkg,
            slide_number=slides[0],
            name=layout_name,
            master_index=master_index,
        )
        created.append(layout_part)

        if palette:
            apply_palette_to_part(pkg, layout_part, palette)

        if assign:
            assign_slides_to_layout(pkg, slides, layout_part)

        if strip_colors or strip_fonts:
            for slide_num in slides:
                slide_part = _slide_part_for_number(pkg, slide_num)
                if strip_colors:
                    strip_colors_from_part(pkg, slide_part)
                if strip_fonts:
                    strip_fonts_from_part(pkg, slide_part)

    return AutoLayoutResult(created_layouts=created, group_count=len(report.groups))


def _slide_part_for_number(pkg: OOXMLPackage, slide_number: int) -> str:
    from .slide_index import slide_parts_in_order

    parts = slide_parts_in_order(pkg)
    if slide_number < 1 or slide_number > len(parts):
        raise ValueError("Slide number out of range")
    return parts[slide_number - 1]



================================================
FILE: src/potxkit/cli.py
================================================
from __future__ import annotations

import argparse
import json
import sys
import xml.etree.ElementTree as ET
from typing import Any

from . import PotxTemplate
from .audit import AuditReport, audit_package
from .auto_layout import auto_layout
from .dump_tree import DumpTreeOptions, dump_tree, summarize_tree
from .layout_ops import (
    add_layout_image_shape,
    apply_palette_to_part,
    assign_slides_to_layout,
    make_layout_from_slide,
    prune_unused_layouts,
    reindex_layouts,
    resolve_layout_part,
    resolve_master_part,
    set_font_family_for_part,
    set_layout_background_image,
    set_layout_text_styles_for_part,
    set_master_text_styles_for_part,
    slide_size,
    strip_colors_from_part,
    strip_fonts_from_part,
)
from .normalize import NormalizeResult, normalize_slide_colors, parse_slide_numbers
from .package import OOXMLPackage
from .sanitize import sanitize_slides
from .slide_index import slide_parts_in_order
from .storage import read_bytes, write_bytes
from .typography import detect_placeholder_styles


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        prog="potxkit",
        description="Edit PowerPoint .potx themes (colors and fonts).",
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    info_parser = subparsers.add_parser("info", help="Show theme info and validation")
    info_parser.add_argument("path", help="Path to .potx/.pptx")

    new_parser = subparsers.add_parser(
        "new", help="Create a new .potx from the bundled base"
    )
    new_parser.add_argument("output", help="Output .potx path")

    apply_parser = subparsers.add_parser(
        "apply-palette", help="Apply a palette JSON to a template"
    )
    apply_parser.add_argument("palette", help="Path to palette JSON")
    apply_parser.add_argument("output", help="Output .potx path")
    apply_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .potx/.pptx (uses bundled base if omitted)",
    )

    validate_parser = subparsers.add_parser(
        "validate", help="Validate theme relationships and content types"
    )
    validate_parser.add_argument("path", help="Path to .potx/.pptx")

    audit_parser = subparsers.add_parser(
        "audit", help="Report per-slide color usage and overrides"
    )
    audit_parser.add_argument("path", help="Path to .pptx/.potx")
    audit_parser.add_argument(
        "--slides",
        help="Slide numbers/ranges to audit (e.g. 1,3-5,8). Defaults to all.",
    )
    audit_parser.add_argument("--output", help="Optional JSON output path")
    audit_parser.add_argument("--pretty", action="store_true", help="Pretty-print JSON")
    audit_parser.add_argument(
        "--summary", action="store_true", help="Print a human-readable summary"
    )
    audit_parser.add_argument(
        "--details",
        action="store_true",
        help="Include per-slide details in summary output",
    )
    audit_parser.add_argument(
        "--group-by",
        help="Group slides by palette/background/layout (e.g. p,b,l). Default: p,l",
    )

    normalize_parser = subparsers.add_parser(
        "normalize", help="Replace hard-coded colors with theme colors"
    )
    normalize_parser.add_argument("mapping", help="Path to mapping JSON")
    normalize_parser.add_argument("output", help="Output .pptx/.potx path")
    normalize_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .pptx/.potx (uses bundled base if omitted)",
    )
    normalize_parser.add_argument(
        "--slides",
        help="Slide numbers/ranges to edit (e.g. 1,3-5,8). Defaults to all.",
    )
    normalize_parser.add_argument(
        "--report",
        help="Optional JSON report path for replacements per slide.",
    )

    palette_parser = subparsers.add_parser(
        "palette-template", help="Print or write an example palette JSON"
    )
    palette_parser.add_argument("--output", help="Optional JSON output path")
    palette_parser.add_argument(
        "--pretty", action="store_true", help="Pretty-print JSON"
    )

    dump_parser = subparsers.add_parser(
        "dump-theme", help="Write the theme colors and fonts as JSON"
    )
    dump_parser.add_argument("path", help="Path to .potx/.pptx")
    dump_parser.add_argument("--output", help="Optional JSON output path")
    dump_parser.add_argument("--pretty", action="store_true", help="Pretty-print JSON")

    colors_parser = subparsers.add_parser("set-colors", help="Set theme colors")
    colors_parser.add_argument("output", help="Output .potx path")
    colors_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .potx/.pptx (uses bundled base if omitted)",
    )
    colors_parser.add_argument("--dark1")
    colors_parser.add_argument("--light1")
    colors_parser.add_argument("--dark2")
    colors_parser.add_argument("--light2")
    for idx in range(1, 7):
        colors_parser.add_argument(f"--accent{idx}")
    colors_parser.add_argument("--hlink")
    colors_parser.add_argument("--folHlink")

    fonts_parser = subparsers.add_parser("set-fonts", help="Set theme fonts")
    fonts_parser.add_argument("output", help="Output .potx path")
    fonts_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .potx/.pptx (uses bundled base if omitted)",
    )
    fonts_parser.add_argument("--major", help="Major font (Latin)")
    fonts_parser.add_argument("--minor", help="Minor font (Latin)")

    master_parser = subparsers.add_parser(
        "set-master", help="Update a slide master's palette or fonts"
    )
    master_parser.add_argument("--master", default="1")
    master_parser.add_argument("--palette")
    master_parser.add_argument("--palette-none", action="store_true")
    master_parser.add_argument("--font")
    master_parser.add_argument("--fonts-none", action="store_true")
    master_parser.add_argument("output", help="Output .pptx/.potx path")
    master_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .pptx/.potx (uses bundled base if omitted)",
    )

    names_parser = subparsers.add_parser(
        "set-theme-names", help="Set theme, color scheme, and font scheme names"
    )
    names_parser.add_argument("output", help="Output .potx path")
    names_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .potx/.pptx (uses bundled base if omitted)",
    )
    names_parser.add_argument("--theme", help="Theme name (slide master UI)")
    names_parser.add_argument("--colors", help="Color scheme name")
    names_parser.add_argument("--fonts", help="Font scheme name")

    make_layout_parser = subparsers.add_parser(
        "make-layout", help="Create a layout from a slide"
    )
    make_layout_parser.add_argument("--from-slide", type=int, required=True)
    make_layout_parser.add_argument("--name", required=True)
    make_layout_parser.add_argument("--master", type=int, default=1)
    make_layout_parser.add_argument(
        "--assign-slides",
        help="Slide numbers/ranges to assign to the new layout",
    )
    make_layout_parser.add_argument("output", help="Output .pptx/.potx path")
    make_layout_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .pptx/.potx (uses bundled base if omitted)",
    )

    set_layout_parser = subparsers.add_parser(
        "set-layout", help="Update a slide layout's palette or fonts"
    )
    set_layout_parser.add_argument("--layout", required=True)
    set_layout_parser.add_argument("--palette")
    set_layout_parser.add_argument("--palette-none", action="store_true")
    set_layout_parser.add_argument("--font")
    set_layout_parser.add_argument("--fonts-none", action="store_true")
    set_layout_parser.add_argument("output", help="Output .pptx/.potx path")
    set_layout_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .pptx/.potx (uses bundled base if omitted)",
    )

    set_slide_parser = subparsers.add_parser(
        "set-slide", help="Update a slide's palette, fonts, or layout"
    )
    set_slide_parser.add_argument(
        "--slide",
        type=int,
        help="Single slide number (1-based)",
    )
    set_slide_parser.add_argument(
        "--slides",
        help="Slide numbers/ranges (e.g. 1,3-5,8)",
    )
    set_slide_parser.add_argument("--layout")
    set_slide_parser.add_argument("--palette")
    set_slide_parser.add_argument("--palette-none", action="store_true")
    set_slide_parser.add_argument("--font")
    set_slide_parser.add_argument("--fonts-none", action="store_true")
    set_slide_parser.add_argument("output", help="Output .pptx/.potx path")
    set_slide_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .pptx/.potx (uses bundled base if omitted)",
    )

    text_styles_parser = subparsers.add_parser(
        "set-text-styles", help="Set title/body text sizes and bold styles"
    )
    text_styles_parser.add_argument("--layout")
    text_styles_parser.add_argument("--master")
    text_styles_parser.add_argument("--from-slide", type=int)
    text_styles_parser.add_argument("--styles", help="Path to styles JSON")
    text_styles_parser.add_argument("--title-size", type=float)
    text_styles_parser.add_argument("--body-size", type=float)
    text_styles_parser.add_argument("--title-bold", action="store_true")
    text_styles_parser.add_argument("--title-regular", action="store_true")
    text_styles_parser.add_argument("--body-bold", action="store_true")
    text_styles_parser.add_argument("--body-regular", action="store_true")
    text_styles_parser.add_argument("output", help="Output .pptx/.potx path")
    text_styles_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .pptx/.potx (uses bundled base if omitted)",
    )

    layout_bg_parser = subparsers.add_parser(
        "set-layout-bg", help="Set a layout background image"
    )
    layout_bg_parser.add_argument("--layout", required=True)
    layout_bg_parser.add_argument("--image", required=True)
    layout_bg_parser.add_argument("output", help="Output .pptx/.potx path")
    layout_bg_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .pptx/.potx (uses bundled base if omitted)",
    )

    layout_img_parser = subparsers.add_parser(
        "set-layout-image", help="Add an image layer to a layout"
    )
    layout_img_parser.add_argument("--layout", required=True)
    layout_img_parser.add_argument("--image", required=True)
    layout_img_parser.add_argument("--x", type=float)
    layout_img_parser.add_argument("--y", type=float)
    layout_img_parser.add_argument("--w", type=float)
    layout_img_parser.add_argument("--h", type=float)
    layout_img_parser.add_argument(
        "--units",
        choices=["in", "emu"],
        default="in",
        help="Units for x/y/w/h (default: in)",
    )
    layout_img_parser.add_argument("--name")
    layout_img_parser.add_argument("output", help="Output .pptx/.potx path")
    layout_img_parser.add_argument(
        "--input",
        dest="input_path",
        help="Optional input .pptx/.potx (uses bundled base if omitted)",
    )

    prune_layouts_parser = subparsers.add_parser(
        "prune-layouts", help="Remove unused slide layouts"
    )
    prune_layouts_parser.add_argument("output", help="Output .pptx/.potx path")
    prune_layouts_parser.add_argument(
        "--input",
        dest="input_path",
        required=True,
        help="Input .pptx/.potx path",
    )
    prune_layouts_parser.add_argument(
        "--keep",
        action="append",
        default=[],
        help="Layout selector to keep (index or name). Can be repeated.",
    )

    reindex_layouts_parser = subparsers.add_parser(
        "reindex-layouts", help="Renumber layouts and update references"
    )
    reindex_layouts_parser.add_argument("output", help="Output .pptx/.potx path")
    reindex_layouts_parser.add_argument(
        "--input",
        dest="input_path",
        required=True,
        help="Input .pptx/.potx path",
    )

    sanitize_parser = subparsers.add_parser(
        "sanitize", help="Add missing OOXML defaults to slides"
    )
    sanitize_parser.add_argument("output", help="Output .pptx/.potx path")
    sanitize_parser.add_argument(
        "--input",
        dest="input_path",
        required=True,
        help="Input .pptx/.potx path",
    )
    sanitize_parser.add_argument(
        "--slides", help="Comma-separated slide numbers or ranges (e.g. 1,3-5)"
    )

    dump_tree_parser = subparsers.add_parser(
        "dump-tree", help="Dump a hierarchical view of slides"
    )
    dump_tree_parser.add_argument("path", help="Input .pptx/.potx path")
    dump_tree_parser.add_argument(
        "--slides", help="Comma-separated slide numbers or ranges"
    )
    dump_tree_parser.add_argument("--layout", action="store_true")
    dump_tree_parser.add_argument("--master", action="store_true")
    dump_tree_parser.add_argument("--text", action="store_true")
    dump_tree_parser.add_argument(
        "--grouped",
        action="store_true",
        help="Group output by slideMaster/slideLayout/local blocks",
    )
    dump_tree_parser.add_argument("--output", help="Write JSON to a file")
    dump_tree_parser.add_argument("--pretty", action="store_true")
    dump_tree_parser.add_argument(
        "--summary",
        action="store_true",
        help="Print a human-friendly summary instead of JSON",
    )
    dump_tree_parser.add_argument(
        "--summary-local-only",
        action="store_true",
        help="Only include slides with local hard-coded colors in summary output",
    )

    auto_layout_parser = subparsers.add_parser(
        "auto-layout", help="Auto-generate layouts by grouping slides"
    )
    auto_layout_parser.add_argument("output", help="Output .pptx/.potx path")
    auto_layout_parser.add_argument(
        "--input",
        dest="input_path",
        help="Input .pptx/.potx",
        required=True,
    )
    auto_layout_parser.add_argument(
        "--group-by",
        help="Group slides by palette/background/layout (e.g. p,b,l). Default: p,l",
    )
    auto_layout_parser.add_argument("--prefix", default="Auto Layout")
    auto_layout_parser.add_argument("--master", type=int, default=1)
    auto_layout_parser.add_argument("--no-assign", action="store_true")
    auto_layout_parser.add_argument("--strip-colors", action="store_true")
    auto_layout_parser.add_argument("--strip-fonts", action="store_true")
    auto_layout_parser.add_argument("--palette")

    args = parser.parse_args(argv)

    if args.command == "info":
        return _handle_info(args.path)
    if args.command == "new":
        return _handle_new(args.output)
    if args.command == "apply-palette":
        return _handle_apply_palette(args.palette, args.output, args.input_path)
    if args.command == "validate":
        return _handle_validate(args.path)
    if args.command == "audit":
        return _handle_audit(args)
    if args.command == "normalize":
        return _handle_normalize(args)
    if args.command == "palette-template":
        return _handle_palette_template(args.output, args.pretty)
    if args.command == "dump-theme":
        return _handle_dump_theme(args.path, args.output, args.pretty)
    if args.command == "set-colors":
        return _handle_set_colors(args)
    if args.command == "set-fonts":
        return _handle_set_fonts(args)
    if args.command == "set-master":
        return _handle_set_master(args)
    if args.command == "set-theme-names":
        return _handle_set_theme_names(args)
    if args.command == "make-layout":
        return _handle_make_layout(args)
    if args.command == "set-layout":
        return _handle_set_layout(args)
    if args.command == "set-slide":
        return _handle_set_slide(args)
    if args.command == "set-text-styles":
        return _handle_set_text_styles(args)
    if args.command == "set-layout-bg":
        return _handle_set_layout_bg(args)
    if args.command == "set-layout-image":
        return _handle_set_layout_image(args)
    if args.command == "prune-layouts":
        return _handle_prune_layouts(args)
    if args.command == "reindex-layouts":
        return _handle_reindex_layouts(args)
    if args.command == "sanitize":
        return _handle_sanitize(args)
    if args.command == "dump-tree":
        return _handle_dump_tree(args)
    if args.command == "auto-layout":
        return _handle_auto_layout(args)

    parser.print_help()
    return 1


def _handle_info(path: str) -> int:
    tpl = PotxTemplate.open(path)
    colors = tpl.theme.colors.as_dict()
    fonts = tpl.theme.fonts

    print("Theme colors:")
    for name, value in colors.items():
        print(f"- {name}: {value}")

    major = fonts.get_major()
    minor = fonts.get_minor()
    print("\nTheme fonts:")
    if major:
        print(f"- major: {major.latin}")
    if minor:
        print(f"- minor: {minor.latin}")

    report = tpl.validate()
    print("\nValidation:")
    print(f"- ok: {report.ok}")
    if report.errors:
        print("- errors:")
        for error in report.errors:
            print(f"  - {error}")
    if report.warnings:
        print("- warnings:")
        for warning in report.warnings:
            print(f"  - {warning}")

    return 0 if report.ok else 1


def _handle_apply_palette(
    palette_path: str, output: str, input_path: str | None
) -> int:
    palette = _load_palette(palette_path)
    tpl = _load_template(input_path)
    _apply_palette(tpl, palette)
    tpl.save(output)
    print(f"Wrote {output}")
    return 0


def _handle_validate(path: str) -> int:
    tpl = PotxTemplate.open(path)
    report = tpl.validate()
    if report.ok:
        print("Validation OK")
        return 0

    print("Validation failed:")
    for error in report.errors:
        print(f"- {error}")
    for warning in report.warnings:
        print(f"- warning: {warning}")
    return 1


def _handle_normalize(args: argparse.Namespace) -> int:
    mapping = _load_mapping(args.mapping)
    data = read_bytes(args.input_path) if args.input_path else None
    if data is None:
        tpl = PotxTemplate.new()
        pkg = tpl._package
    else:
        pkg = OOXMLPackage(data)

    slide_numbers = parse_slide_numbers(args.slides) if args.slides else None
    result = normalize_slide_colors(pkg, mapping, slide_numbers)
    write_bytes(args.output, pkg.save_bytes())
    _print_normalize_result(result)

    if args.report:
        with open(args.report, "w", encoding="utf-8") as handle:
            json.dump(_normalize_report(result), handle, indent=2)
        print(f"Wrote {args.report}")

    return 0


def _handle_audit(args: argparse.Namespace) -> int:
    data = read_bytes(args.path)
    pkg = OOXMLPackage(data)
    slide_numbers = parse_slide_numbers(args.slides) if args.slides else None
    try:
        group_by = _parse_group_by(args.group_by)
    except ValueError as exc:
        print(str(exc))
        return 2
    report = audit_package(pkg, slide_numbers, group_by=group_by)

    payload = _audit_report(report)
    if args.output:
        with open(args.output, "w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2 if args.pretty else None)
        print(f"Wrote {args.output}")
    if not args.output and not args.summary:
        json.dump(payload, sys.stdout, indent=2 if args.pretty else None)
        print()
    if args.summary:
        _print_audit_summary(report, details=args.details)

    return 0


def _handle_new(output: str) -> int:
    tpl = PotxTemplate.new()
    tpl.save(output)
    print(f"Wrote {output}")
    return 0


def _handle_dump_theme(path: str, output: str | None, pretty: bool) -> int:
    tpl = PotxTemplate.open(path)
    payload = _theme_to_json(tpl)
    if output:
        with open(output, "w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2 if pretty else None)
        print(f"Wrote {output}")
    else:
        json.dump(payload, sys.stdout, indent=2 if pretty else None)
        print()
    return 0


def _handle_set_colors(args: argparse.Namespace) -> int:
    tpl = _load_template(args.input_path)
    colors = tpl.theme.colors
    updates = 0

    updates += _set_if_present(colors.set_dark1, vars(args), "dark1")
    updates += _set_if_present(colors.set_light1, vars(args), "light1")
    updates += _set_if_present(colors.set_dark2, vars(args), "dark2")
    updates += _set_if_present(colors.set_light2, vars(args), "light2")
    for idx in range(1, 7):
        key = f"accent{idx}"
        if key in vars(args) and getattr(args, key) is not None:
            colors.set_accent(idx, getattr(args, key))
            updates += 1
    updates += _set_if_present(colors.set_hyperlink, vars(args), "hlink")
    updates += _set_if_present(colors.set_followed_hyperlink, vars(args), "folHlink")

    if updates == 0:
        print("No colors specified. Use --accent1, --dark1, etc.")
        return 2

    tpl.save(args.output)
    print(f"Wrote {args.output}")
    return 0


def _handle_set_fonts(args: argparse.Namespace) -> int:
    if not args.major and not args.minor:
        print("No fonts specified. Use --major and/or --minor.")
        return 2

    tpl = _load_template(args.input_path)
    if args.major:
        tpl.theme.fonts.set_major(args.major)
    if args.minor:
        tpl.theme.fonts.set_minor(args.minor)

    tpl.save(args.output)
    print(f"Wrote {args.output}")
    return 0


def _handle_palette_template(output: str | None, pretty: bool) -> int:
    payload = _example_palette()
    if output:
        with open(output, "w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2 if pretty else None)
        print(f"Wrote {output}")
    else:
        json.dump(payload, sys.stdout, indent=2 if pretty else None)
        print()
    return 0


def _handle_set_theme_names(args: argparse.Namespace) -> int:
    if not args.theme and not args.colors and not args.fonts:
        print("No names specified. Use --theme, --colors, and/or --fonts.")
        return 2

    tpl = _load_template(args.input_path)
    if args.theme:
        tpl.theme.set_name(args.theme)
    if args.colors:
        tpl.theme.set_color_scheme_name(args.colors)
    if args.fonts:
        tpl.theme.set_font_scheme_name(args.fonts)

    tpl.save(args.output)
    print(f"Wrote {args.output}")
    return 0


def _handle_set_master(args: argparse.Namespace) -> int:
    try:
        _validate_palette_font_args(args)
    except ValueError as exc:
        print(str(exc))
        return 2
    data = read_bytes(args.input_path) if args.input_path else None
    pkg = OOXMLPackage(data) if data else PotxTemplate.new()._package

    master_part = resolve_master_part(pkg, str(args.master))
    _apply_palette_and_fonts(pkg, master_part, args)

    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    return 0


def _handle_make_layout(args: argparse.Namespace) -> int:
    data = read_bytes(args.input_path) if args.input_path else None
    pkg = OOXMLPackage(data) if data else PotxTemplate.new()._package

    new_layout = make_layout_from_slide(
        pkg,
        slide_number=args.from_slide,
        name=args.name,
        master_index=args.master,
    )
    if args.assign_slides:
        slides = parse_slide_numbers(args.assign_slides)
        assign_slides_to_layout(pkg, slides, new_layout)

    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    print(f"Layout created: {new_layout}")
    return 0


def _handle_set_layout(args: argparse.Namespace) -> int:
    try:
        _validate_palette_font_args(args)
    except ValueError as exc:
        print(str(exc))
        return 2
    data = read_bytes(args.input_path) if args.input_path else None
    pkg = OOXMLPackage(data) if data else PotxTemplate.new()._package

    layout_part = resolve_layout_part(pkg, args.layout)
    _apply_palette_and_fonts(pkg, layout_part, args)

    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    return 0


def _handle_set_slide(args: argparse.Namespace) -> int:
    try:
        _validate_palette_font_args(args)
    except ValueError as exc:
        print(str(exc))
        return 2
    if args.slide is None and not args.slides:
        print("Provide --slide or --slides.")
        return 2
    data = read_bytes(args.input_path) if args.input_path else None
    pkg = OOXMLPackage(data) if data else PotxTemplate.new()._package

    if args.slides:
        slide_numbers = parse_slide_numbers(args.slides)
    else:
        slide_numbers = parse_slide_numbers(str(args.slide))
    slide_parts = _slide_parts_for_numbers(pkg, slide_numbers)

    for slide_part in slide_parts:
        _apply_palette_and_fonts(pkg, slide_part, args)

    if args.layout:
        layout_part = resolve_layout_part(pkg, args.layout)
        assign_slides_to_layout(pkg, slide_numbers, layout_part)

    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    return 0


def _handle_set_text_styles(args: argparse.Namespace) -> int:
    if not args.layout and not args.master:
        print("Provide --layout and/or --master.")
        return 2
    if args.title_bold and args.title_regular:
        print("Use only one of --title-bold or --title-regular.")
        return 2
    if args.body_bold and args.body_regular:
        print("Use only one of --body-bold or --body-regular.")
        return 2

    data = read_bytes(args.input_path) if args.input_path else None
    pkg = OOXMLPackage(data) if data else PotxTemplate.new()._package

    title_size = args.title_size
    body_size = args.body_size
    title_bold = True if args.title_bold else False if args.title_regular else None
    body_bold = True if args.body_bold else False if args.body_regular else None

    if args.styles:
        styles = _load_styles(args.styles)
        title = styles.get("title", {})
        body = styles.get("body", {})
        title_size = title.get("size", title_size)
        body_size = body.get("size", body_size)
        if "bold" in title:
            title_bold = bool(title.get("bold"))
        if "bold" in body:
            body_bold = bool(body.get("bold"))

    if args.from_slide:
        slide_part = _slide_parts_for_numbers(pkg, {args.from_slide})[0]
        slide_root = ET.fromstring(pkg.read_part(slide_part))
        detected = detect_placeholder_styles(slide_root)
        if title_size is None and detected.get("title", {}).get("size_pt") is not None:
            title_size = detected["title"]["size_pt"]
        if body_size is None and detected.get("body", {}).get("size_pt") is not None:
            body_size = detected["body"]["size_pt"]
        if title_bold is None and detected.get("title", {}).get("bold") is not None:
            title_bold = detected["title"]["bold"]
        if body_bold is None and detected.get("body", {}).get("bold") is not None:
            body_bold = detected["body"]["bold"]

    if args.layout:
        layout_part = resolve_layout_part(pkg, args.layout)
        set_layout_text_styles_for_part(
            pkg, layout_part, title_size, title_bold, body_size, body_bold
        )
    if args.master:
        master_part = resolve_master_part(pkg, str(args.master))
        set_master_text_styles_for_part(
            pkg, master_part, title_size, title_bold, body_size, body_bold
        )

    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    return 0


def _load_styles(path: str) -> dict[str, Any]:
    with open(path, "r", encoding="utf-8") as handle:
        data = json.load(handle)
    if not isinstance(data, dict):
        raise ValueError("Styles JSON must be an object")
    return data


def _handle_set_layout_bg(args: argparse.Namespace) -> int:
    data = read_bytes(args.input_path) if args.input_path else None
    pkg = OOXMLPackage(data) if data else PotxTemplate.new()._package
    layout_part = resolve_layout_part(pkg, args.layout)
    set_layout_background_image(pkg, layout_part, args.image)
    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    return 0


def _handle_set_layout_image(args: argparse.Namespace) -> int:
    data = read_bytes(args.input_path) if args.input_path else None
    pkg = OOXMLPackage(data) if data else PotxTemplate.new()._package
    layout_part = resolve_layout_part(pkg, args.layout)

    cx, cy = slide_size(pkg)
    x, y, w, h = _resolve_image_box(args, cx, cy)
    add_layout_image_shape(pkg, layout_part, args.image, x, y, w, h, args.name)
    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    return 0


def _handle_prune_layouts(args: argparse.Namespace) -> int:
    data = read_bytes(args.input_path)
    pkg = OOXMLPackage(data)

    keep_layouts = set()
    for selector in args.keep:
        keep_layouts.add(resolve_layout_part(pkg, selector))

    result = prune_unused_layouts(pkg, keep_layouts=keep_layouts or None)
    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    print(f"Layouts removed: {len(result.removed_layouts)}")
    return 0


def _handle_reindex_layouts(args: argparse.Namespace) -> int:
    data = read_bytes(args.input_path)
    pkg = OOXMLPackage(data)
    result = reindex_layouts(pkg)
    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    print(f"Layouts remapped: {len(result.layout_mapping)}")
    return 0


def _handle_sanitize(args: argparse.Namespace) -> int:
    data = read_bytes(args.input_path)
    pkg = OOXMLPackage(data)
    slide_numbers = parse_slide_numbers(args.slides) if args.slides else None
    result = sanitize_slides(pkg, slide_numbers)
    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    print(
        f"Slides updated: {result.slides_updated} "
        f"(clrMapOvr={result.clrmap_added}, lstStyle={result.lststyle_added}, "
        f"bgNoFill={result.bg_nofill_added})"
    )
    return 0


def _handle_dump_tree(args: argparse.Namespace) -> int:
    data = read_bytes(args.path)
    pkg = OOXMLPackage(data)
    slide_numbers = parse_slide_numbers(args.slides) if args.slides else None
    include_layout = args.layout
    include_master = args.master
    if args.grouped and not include_layout and not include_master:
        include_layout = True
        include_master = True
    options = DumpTreeOptions(
        include_layout=include_layout,
        include_master=include_master,
        include_text=args.text,
        grouped=args.grouped,
    )
    payload = dump_tree(pkg, slide_numbers=slide_numbers, options=options)
    if args.summary:
        lines = summarize_tree(payload, local_only=args.summary_local_only)
        output = "\n".join(lines)
        if args.output:
            with open(args.output, "w", encoding="utf-8") as handle:
                handle.write(output)
                handle.write("\n")
            print(f"Wrote {args.output}")
            return 0
        print(output)
        return 0
    if args.summary_local_only and not args.summary:
        print("Use --summary with --summary-local-only.")
        return 2

    if args.output:
        with open(args.output, "w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2 if args.pretty else None)
        print(f"Wrote {args.output}")
        return 0
    json.dump(payload, sys.stdout, indent=2 if args.pretty else None)
    print()
    return 0


def _handle_auto_layout(args: argparse.Namespace) -> int:
    data = read_bytes(args.input_path)
    pkg = OOXMLPackage(data)
    try:
        group_by = _parse_group_by(args.group_by)
    except ValueError as exc:
        print(str(exc))
        return 2
    palette = _load_mapping(args.palette) if args.palette else None

    result = auto_layout(
        pkg,
        group_by=group_by,
        prefix=args.prefix,
        master_index=args.master,
        assign=not args.no_assign,
        strip_colors=args.strip_colors,
        strip_fonts=args.strip_fonts,
        palette=palette,
    )
    write_bytes(args.output, pkg.save_bytes())
    print(f"Wrote {args.output}")
    print(f"Layouts created: {len(result.created_layouts)}")
    return 0


def _load_palette(path: str) -> dict[str, Any]:
    with open(path, "r", encoding="utf-8") as handle:
        data = json.load(handle)
    if not isinstance(data, dict):
        raise ValueError("Palette JSON must be an object")
    return data


def _load_mapping(path: str) -> dict[str, Any]:
    with open(path, "r", encoding="utf-8") as handle:
        data = json.load(handle)
    if not isinstance(data, dict):
        raise ValueError("Mapping JSON must be an object")
    return data


def _apply_palette(tpl: PotxTemplate, palette: dict[str, Any]) -> None:
    colors = tpl.theme.colors

    _set_if_present(colors.set_dark1, palette, "dark1")
    _set_if_present(colors.set_light1, palette, "light1")
    _set_if_present(colors.set_dark2, palette, "dark2")
    _set_if_present(colors.set_light2, palette, "light2")

    for idx in range(1, 7):
        key = f"accent{idx}"
        if key in palette:
            colors.set_accent(idx, palette[key])

    _set_if_present(colors.set_hyperlink, palette, "hlink")
    _set_if_present(colors.set_followed_hyperlink, palette, "folHlink")

    fonts = tpl.theme.fonts
    if "majorFont" in palette:
        fonts.set_major(palette["majorFont"])
    if "minorFont" in palette:
        fonts.set_minor(palette["minorFont"])


def _theme_to_json(tpl: PotxTemplate) -> dict[str, Any]:
    colors = tpl.theme.colors.as_dict()
    fonts = tpl.theme.fonts
    major = fonts.get_major()
    minor = fonts.get_minor()
    payload: dict[str, Any] = dict(colors)
    if major:
        payload["majorFont"] = major.latin
    if minor:
        payload["minorFont"] = minor.latin
    return payload


def _apply_palette_and_fonts(
    pkg: OOXMLPackage, part: str, args: argparse.Namespace
) -> None:
    if args.palette:
        mapping = _load_mapping(args.palette)
        apply_palette_to_part(pkg, part, mapping)
    if args.palette_none:
        strip_colors_from_part(pkg, part)
    if args.font:
        set_font_family_for_part(pkg, part, args.font)
    if args.fonts_none:
        strip_fonts_from_part(pkg, part)


def _validate_palette_font_args(args: argparse.Namespace) -> None:
    if args.palette and args.palette_none:
        raise ValueError("Use either --palette or --palette-none, not both.")
    if args.font and args.fonts_none:
        raise ValueError("Use either --font or --fonts-none, not both.")


def _slide_parts_for_numbers(pkg: OOXMLPackage, slide_numbers: set[int]) -> list[str]:
    parts = slide_parts_in_order(pkg)
    selected = []
    for num in sorted(slide_numbers):
        if num < 1 or num > len(parts):
            raise ValueError("Slide number out of range")
        selected.append(parts[num - 1])
    return selected


def _resolve_image_box(
    args: argparse.Namespace, cx: int, cy: int
) -> tuple[int, int, int, int]:
    x = args.x if args.x is not None else 0
    y = args.y if args.y is not None else 0
    w = args.w if args.w is not None else None
    h = args.h if args.h is not None else None

    if args.units == "emu":
        return (
            int(x),
            int(y),
            int(w if w is not None else cx),
            int(h if h is not None else cy),
        )

    factor = 914400
    x_emu = int(x * factor)
    y_emu = int(y * factor)
    w_emu = int(w * factor) if w is not None else cx
    h_emu = int(h * factor) if h is not None else cy
    return (x_emu, y_emu, w_emu, h_emu)


def _load_template(input_path: str | None) -> PotxTemplate:
    return PotxTemplate.open(input_path) if input_path else PotxTemplate.new()


def _example_palette() -> dict[str, Any]:
    return {
        "dark1": "#FFFFFF",
        "light1": "#0B0B0E",
        "dark2": "#2C2C34",
        "light2": "#E9ECF2",
        "accent1": "#1F6BFF",
        "accent2": "#E0328C",
        "accent3": "#F6A225",
        "accent4": "#6B3AF6",
        "accent5": "#38D3FF",
        "accent6": "#FF4D6D",
        "hlink": "#1F6BFF",
        "folHlink": "#C0186B",
        "majorFont": "Aptos Display",
        "minorFont": "Aptos",
    }


def _normalize_report(result: NormalizeResult) -> dict[str, Any]:
    return {
        "slides_total": result.slides_total,
        "slides_touched": result.slides_touched,
        "replacements": result.replacements,
        "per_slide": result.per_slide,
    }


def _audit_report(report: AuditReport) -> dict[str, Any]:
    return {
        "slides_total": report.slides_total,
        "slides_audited": report.slides_audited,
        "per_slide": report.per_slide,
        "masters": report.masters,
        "layouts": report.layouts,
        "groups": report.groups,
        "theme": report.theme,
        "group_by": report.group_by,
    }


def _print_normalize_result(result: NormalizeResult) -> None:
    print(
        "Replacements: {replacements} across {slides} slide(s)".format(
            replacements=result.replacements, slides=result.slides_touched
        )
    )
    if result.per_slide:
        print("Per slide:")
        for slide, count in sorted(result.per_slide.items()):
            print(f"- {slide}: {count}")


def _print_audit_summary(report: AuditReport, *, details: bool) -> None:
    print("Legend:")
    print("- srgbClr: hard-coded hex color")
    print("- schemeClr: theme-based color slot (accent1, dk1, etc.)")
    print("- sysClr: system color (Office-defined)")
    print("- clrMapOvr: slide overrides the master color mapping")
    print("- custom_bg: slide has a background override")
    print("- images: count of pictures or bitmap fills on the slide")
    print("")

    if report.theme:
        print("Theme:")
        theme = report.theme
        print(f"- part: {theme.get('part', '')}")
        print(f"- theme name: {theme.get('theme_name', '') or '(unset)'}")
        print(f"- color scheme: {theme.get('color_scheme_name', '') or '(unset)'}")
        print(f"- font scheme: {theme.get('font_scheme_name', '') or '(unset)'}")
        print("")

    print(f"Slides audited: {report.slides_audited}/{report.slides_total}")
    if report.masters:
        print("Masters:")
        for part, stats in report.masters.items():
            print(
                f"- {part}: srgb={stats['color_counts']['srgb']}, "
                f"scheme={stats['color_counts']['scheme']}, "
                f"fills={stats['fills']['solid']}/{stats['fills']['grad']}/"
                f"{stats['fills']['blip']}, pics={stats['pictures']}"
            )
    if report.layouts:
        print("Layouts:")
        for part, stats in report.layouts.items():
            print(
                f"- {part}: srgb={stats['color_counts']['srgb']}, "
                f"scheme={stats['color_counts']['scheme']}, "
                f"fills={stats['fills']['solid']}/{stats['fills']['grad']}/"
                f"{stats['fills']['blip']}, pics={stats['pictures']}"
            )

    if report.groups:
        print(f"Groups (group_by={','.join(report.group_by)}):")
        for group in report.groups:
            slides = _format_slide_ranges(group["slides"])
            palette = _format_palette(group["palette"])
            print(f"- slides: {slides}")
            if group.get("layout_part"):
                print(f"  layout: {group['layout_part']}")
            if group.get("master_part"):
                print(f"  master: {group['master_part']}")
            if group.get("background"):
                print(f"  background: {group['background']}")
            if palette:
                print(f"  palette: {palette}")
            print(
                f"  hardcoded_total={group['hardcoded_total']} "
                f"(text={group['text_srgb_total']}, shape={group['shape_srgb_total']})"
            )
            if group["clrMapOvr_slides"]:
                print(f"  clrMapOvr slides: {group['clrMapOvr_slides']}")
            if group["custom_bg_slides"]:
                print(f"  custom_bg slides: {group['custom_bg_slides']}")
            if group["image_slides"]:
                print(f"  image slides: {group['image_slides']}")

        _print_group_recommendations(report.groups)

    if not details:
        return

    for slide in sorted(report.per_slide):
        data = report.per_slide[slide]
        counts = data["color_counts"]
        text_counts = data["text_colors"]
        shape_counts = data["shape_colors"]
        fills = data["fills"]
        bg = data["background"]
        flags = []
        hardcoded = counts["srgb"] + counts["sysclr"]
        hardcoded_details = []
        if text_counts["srgb"]:
            hardcoded_details.append(f"text={text_counts['srgb']}")
        if shape_counts["srgb"]:
            hardcoded_details.append(f"shape={shape_counts['srgb']}")
        if hardcoded:
            if hardcoded_details:
                flags.append(f"hardcoded={hardcoded} ({', '.join(hardcoded_details)})")
            else:
                flags.append(f"hardcoded={hardcoded}")
        if data["has_clrMapOvr"]:
            flags.append("clrMapOvr")
        if data["pictures"] or fills["blip"]:
            flags.append(f"images={data['pictures']}")
        if bg["bg_blip"] or bg["bg_grad"] or bg["bg_solid"] or bg["bg_ref"]:
            flags.append("custom_bg")

        top_colors = _format_top_colors(data["top_srgb"])
        summary = ", ".join(flags) if flags else "no overrides detected"
        slide_part = data.get("slide_part", "")
        layout_part = data.get("layout_part", "")
        master_part = data.get("master_part", "")
        print(f"- slide {slide}: {summary}")
        if slide_part:
            print(f"  part: {slide_part}")
        if layout_part:
            print(f"  layout: {layout_part}")
        if master_part:
            print(f"  master: {master_part}")
        if top_colors:
            print(f"  top colors: {top_colors}")
        top_sizes = _format_top_sizes(data.get("text_styles", {}).get("top_sizes", []))
        if top_sizes:
            print(f"  top sizes: {top_sizes}")


def _format_top_colors(entries: list[dict[str, int]]) -> str:
    return ", ".join([f"#{entry['value']}({entry['count']})" for entry in entries])


def _format_palette(values: list[str]) -> str:
    return ", ".join([f"#{value}" for value in values])


def _format_top_sizes(entries: list[dict[str, float]]) -> str:
    parts = []
    for entry in entries:
        pt = entry.get("pt")
        count = entry.get("count")
        if pt is None or count is None:
            continue
        parts.append(f"{pt:g}pt({count})")
    return ", ".join(parts)


def _format_slide_ranges(slides: list[int]) -> str:
    if not slides:
        return ""
    ranges = []
    start = prev = slides[0]
    for num in slides[1:]:
        if num == prev + 1:
            prev = num
            continue
        ranges.append(_format_range(start, prev))
        start = prev = num
    ranges.append(_format_range(start, prev))
    return ", ".join(ranges)


def _format_range(start: int, end: int) -> str:
    return f"{start}-{end}" if start != end else str(start)


def _print_group_recommendations(groups: list[dict[str, Any]]) -> None:
    by_layout: dict[str, list[dict[str, Any]]] = {}
    for group in groups:
        layout = group.get("layout_part") or "(none)"
        by_layout.setdefault(layout, []).append(group)

    recommendations = []
    for layout, items in by_layout.items():
        if len(items) > 1:
            recommendations.append((layout, items))

    if not recommendations:
        return

    print("Recommendations:")
    for layout, items in recommendations:
        palettes = [group.get("palette", []) for group in items]
        slide_sets = [_format_slide_ranges(group["slides"]) for group in items]
        print(
            f"- layout {layout} has {len(items)} palettes; "
            "consider splitting into separate layouts."
        )
        for palette, slides in zip(palettes, slide_sets):
            palette_text = _format_palette(palette)
            print(f"  slides {slides}: {palette_text or '(no palette detected)'}")


def _parse_group_by(value: str | None) -> list[str]:
    if not value:
        return ["p", "l"]
    tokens = [token.strip() for token in value.split(",") if token.strip()]
    if len(tokens) == 1 and len(tokens[0]) > 1:
        tokens = list(tokens[0])
    valid = {"p", "b", "l"}
    result = []
    for token in tokens:
        if token not in valid:
            raise ValueError("group-by must be a combination of p,b,l")
        if token not in result:
            result.append(token)
    return result


def _set_if_present(func, mapping: dict[str, Any], key: str) -> int:
    if key in mapping and mapping[key] is not None:
        func(mapping[key])
        return 1
    return 0


if __name__ == "__main__":
    raise SystemExit(main())



================================================
FILE: src/potxkit/content_types.py
================================================
from __future__ import annotations

import xml.etree.ElementTree as ET

from .package import OOXMLPackage

CT_NS = "http://schemas.openxmlformats.org/package/2006/content-types"


class ContentTypes:
    def __init__(self, root: ET.Element) -> None:
        self._root = root

    @classmethod
    def from_bytes(cls, xml_bytes: bytes) -> "ContentTypes":
        return cls(ET.fromstring(xml_bytes))

    def ensure_override(self, part_name: str, content_type: str) -> bool:
        part = _normalize_part_name(part_name)
        for override in self._root.findall(f"{{{CT_NS}}}Override"):
            if override.attrib.get("PartName") == part:
                return False
        ET.SubElement(
            self._root,
            f"{{{CT_NS}}}Override",
            {"PartName": part, "ContentType": content_type},
        )
        return True

    def remove_override(self, part_name: str) -> bool:
        part = _normalize_part_name(part_name)
        removed = False
        for override in list(self._root.findall(f"{{{CT_NS}}}Override")):
            if override.attrib.get("PartName") == part:
                self._root.remove(override)
                removed = True
        return removed

    def to_bytes(self) -> bytes:
        return ET.tostring(self._root, encoding="utf-8", xml_declaration=True)


def ensure_override(pkg: OOXMLPackage, part_name: str, content_type: str) -> bool:
    if not pkg.has_part("[Content_Types].xml"):
        raise KeyError("[Content_Types].xml not found")
    ct = ContentTypes.from_bytes(pkg.read_part("[Content_Types].xml"))
    changed = ct.ensure_override(part_name, content_type)
    if changed:
        pkg.write_part("[Content_Types].xml", ct.to_bytes())
    return changed


def remove_override(pkg: OOXMLPackage, part_name: str) -> bool:
    if not pkg.has_part("[Content_Types].xml"):
        return False
    ct = ContentTypes.from_bytes(pkg.read_part("[Content_Types].xml"))
    changed = ct.remove_override(part_name)
    if changed:
        pkg.write_part("[Content_Types].xml", ct.to_bytes())
    return changed


def ensure_default(pkg: OOXMLPackage, extension: str, content_type: str) -> bool:
    if not pkg.has_part("[Content_Types].xml"):
        raise KeyError("[Content_Types].xml not found")
    ct = ContentTypes.from_bytes(pkg.read_part("[Content_Types].xml"))
    changed = _ensure_default_element(ct, extension, content_type)
    if changed:
        pkg.write_part("[Content_Types].xml", ct.to_bytes())
    return changed


def has_override(pkg: OOXMLPackage, part_name: str) -> bool:
    if not pkg.has_part("[Content_Types].xml"):
        return False
    ct = ContentTypes.from_bytes(pkg.read_part("[Content_Types].xml"))
    part = _normalize_part_name(part_name)
    for override in ct._root.findall(f"{{{CT_NS}}}Override"):
        if override.attrib.get("PartName") == part:
            return True
    return False


def _normalize_part_name(part_name: str) -> str:
    return part_name if part_name.startswith("/") else f"/{part_name}"


def _ensure_default_element(
    ct: ContentTypes, extension: str, content_type: str
) -> bool:
    ext = extension.lower().lstrip(".")
    for default in ct._root.findall(f"{{{CT_NS}}}Default"):
        if default.attrib.get("Extension") == ext:
            return False
    ET.SubElement(
        ct._root,
        f"{{{CT_NS}}}Default",
        {"Extension": ext, "ContentType": content_type},
    )
    return True



================================================
FILE: src/potxkit/dump_tree.py
================================================
from __future__ import annotations

import posixpath
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Any, Iterable

from .package import OOXMLPackage
from .rels import parse_relationships, rels_part_for
from .slide_index import slide_parts_in_order

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
R_NS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"

NS = {"p": P_NS, "a": A_NS, "r": R_NS}


@dataclass
class DumpTreeOptions:
    include_layout: bool = False
    include_master: bool = False
    include_text: bool = False
    grouped: bool = False


def dump_tree(
    pkg: OOXMLPackage,
    slide_numbers: Iterable[int] | None = None,
    options: DumpTreeOptions | None = None,
) -> dict[str, Any]:
    opts = options or DumpTreeOptions()
    slide_parts = slide_parts_in_order(pkg)

    if slide_numbers is not None:
        requested = {num for num in slide_numbers}
        selected = []
        for num in sorted(requested):
            if num < 1 or num > len(slide_parts):
                raise ValueError("Slide number out of range")
            selected.append(slide_parts[num - 1])
        slide_parts = selected

    slides = []
    for idx, slide_part in enumerate(slide_parts, start=1):
        slide_root = ET.fromstring(pkg.read_part(slide_part))
        layout_part = _slide_layout_part(pkg, slide_part)
        master_part = _layout_master_part(pkg, layout_part) if layout_part else None

        if opts.grouped:
            entry = {
                "slide": idx,
                "part": slide_part,
                "layout": layout_part,
                "master": master_part,
                "local": _collect_layer(slide_root, include_text=opts.include_text),
            }
            if opts.include_layout and layout_part:
                layout_root = ET.fromstring(pkg.read_part(layout_part))
                entry["slideLayout"] = _collect_layer(
                    layout_root, include_text=opts.include_text, part=layout_part
                )
            if opts.include_master and master_part:
                master_root = ET.fromstring(pkg.read_part(master_part))
                entry["slideMaster"] = _collect_layer(
                    master_root, include_text=opts.include_text, part=master_part
                )
            slides.append(entry)
            continue

        slide_entry = {
            "slide": idx,
            "part": slide_part,
            "layout": layout_part,
            "master": master_part,
            "background": _extract_background(slide_root),
            "shapes": _extract_shapes(slide_root, include_text=opts.include_text),
            "has_clrMapOvr": slide_root.find("p:clrMapOvr", NS) is not None,
        }

        if opts.include_layout and layout_part:
            layout_root = ET.fromstring(pkg.read_part(layout_part))
            slide_entry["layout_tree"] = _collect_layer(
                layout_root, include_text=opts.include_text, part=layout_part
            )

        if opts.include_master and master_part:
            master_root = ET.fromstring(pkg.read_part(master_part))
            slide_entry["master_tree"] = _collect_layer(
                master_root, include_text=opts.include_text, part=master_part
            )

        slides.append(slide_entry)

    return {"slides": slides}


def summarize_tree(payload: dict[str, Any], *, local_only: bool = False) -> list[str]:
    lines: list[str] = []
    slides = payload.get("slides", [])
    for slide in slides:
        if local_only and not _slide_has_local_hardcoded(slide):
            continue
        lines.append(f"slide {slide.get('slide')}:")
        for key in ["slideMaster", "slideLayout", "local"]:
            if key not in slide:
                continue
            summary = _summarize_layer(slide[key])
            line = (
                f"  {key}: bg={summary['bg']} "
                f"fills(hard={summary['shape_fill_hard']}, theme={summary['shape_fill_theme']}) "
                f"text(hard={summary['text_color_hard']}, theme={summary['text_color_theme']}) "
                f"fonts={summary['fonts']} sizes={summary['sizes']} "
                f"clrMap={summary['clrmap']}"
            )
            lines.append(line)
    return lines


def _collect_layer(
    root: ET.Element, *, include_text: bool, part: str | None = None
) -> dict[str, Any]:
    data = {
        "part": part,
        "name": _part_basename(part) if part else None,
        "background": _extract_background(root),
        "shapes": _extract_shapes(root, include_text=include_text),
        "has_clrMap": root.find(".//p:clrMap", NS) is not None,
        "has_clrMapOvr": root.find(".//p:clrMapOvr", NS) is not None,
    }
    return data


def _slide_layout_part(pkg: OOXMLPackage, slide_part: str) -> str | None:
    rels_part = rels_part_for(slide_part)
    if not pkg.has_part(rels_part):
        return None
    relationships = parse_relationships(pkg.read_part(rels_part))
    for rel in relationships:
        if rel.type.endswith("/slideLayout"):
            return _resolve_target(posixpath.dirname(slide_part), rel.target)
    return None


def _layout_master_part(pkg: OOXMLPackage, layout_part: str | None) -> str | None:
    if not layout_part:
        return None
    rels_part = rels_part_for(layout_part)
    if not pkg.has_part(rels_part):
        return None
    relationships = parse_relationships(pkg.read_part(rels_part))
    for rel in relationships:
        if rel.type.endswith("/slideMaster"):
            return _resolve_target(posixpath.dirname(layout_part), rel.target)
    return None


def _resolve_target(base_dir: str, target: str) -> str:
    if target.startswith("/"):
        return target[1:]
    return posixpath.normpath(posixpath.join(base_dir, target))


def _extract_background(root: ET.Element) -> dict[str, Any] | None:
    bg_pr = root.find("p:cSld/p:bg/p:bgPr", NS)
    if bg_pr is None:
        return None
    fill = _extract_fill(bg_pr)
    return {"fill": fill} if fill else None


def _extract_shapes(root: ET.Element, *, include_text: bool) -> list[dict[str, Any]]:
    sp_tree = root.find("p:cSld/p:spTree", NS)
    if sp_tree is None:
        return []
    return [_extract_shape(node, include_text=include_text) for node in list(sp_tree)]


def _extract_shape(node: ET.Element, *, include_text: bool) -> dict[str, Any]:
    tag = _local_name(node.tag)
    if tag == "sp":
        return _extract_sp(node, include_text=include_text)
    if tag == "pic":
        return _extract_pic(node)
    if tag == "graphicFrame":
        return _extract_graphic_frame(node)
    if tag == "grpSp":
        return _extract_group(node, include_text=include_text)
    return {"type": tag}


def _extract_sp(node: ET.Element, *, include_text: bool) -> dict[str, Any]:
    c_nv_pr = node.find("p:nvSpPr/p:cNvPr", NS)
    info = _shape_identity(c_nv_pr)
    ph = node.find("p:nvSpPr/p:nvPr/p:ph", NS)
    if ph is not None:
        info["placeholder"] = {
            "type": ph.attrib.get("type"),
            "idx": ph.attrib.get("idx"),
        }
    sp_pr = node.find("p:spPr", NS)
    if sp_pr is not None:
        fill = _extract_fill(sp_pr)
        if fill:
            info["fill"] = fill
    if include_text:
        tx_body = node.find("p:txBody", NS)
        if tx_body is not None:
            info["text"] = _extract_text_info(tx_body)
    return {"type": "shape", **info}


def _extract_pic(node: ET.Element) -> dict[str, Any]:
    c_nv_pr = node.find("p:nvPicPr/p:cNvPr", NS)
    info = _shape_identity(c_nv_pr)
    blip = node.find("p:blipFill/a:blip", NS)
    if blip is not None:
        embed = blip.attrib.get(f"{{{R_NS}}}embed")
        if embed:
            info["embed"] = embed
    fill = _extract_fill(node)
    if fill:
        info["fill"] = fill
    return {"type": "picture", **info}


def _extract_graphic_frame(node: ET.Element) -> dict[str, Any]:
    c_nv_pr = node.find("p:nvGraphicFramePr/p:cNvPr", NS)
    info = _shape_identity(c_nv_pr)
    graphic = node.find("a:graphic/a:graphicData", NS)
    if graphic is not None:
        info["graphic_uri"] = graphic.attrib.get("uri")
    return {"type": "graphicFrame", **info}


def _extract_group(node: ET.Element, *, include_text: bool) -> dict[str, Any]:
    c_nv_pr = node.find("p:nvGrpSpPr/p:cNvPr", NS)
    info = _shape_identity(c_nv_pr)
    children_tree = node.find("p:grpSp/p:spTree", NS)
    children = []
    if children_tree is not None:
        children = [
            _extract_shape(child, include_text=include_text)
            for child in list(children_tree)
        ]
    return {"type": "group", **info, "children": children}


def _shape_identity(c_nv_pr: ET.Element | None) -> dict[str, Any]:
    if c_nv_pr is None:
        return {}
    return {"id": c_nv_pr.attrib.get("id"), "name": c_nv_pr.attrib.get("name")}


def _extract_text_info(tx_body: ET.Element) -> dict[str, Any]:
    paragraphs = tx_body.findall("a:p", NS)
    runs = tx_body.findall(".//a:r", NS)
    colors = _extract_color_nodes(tx_body)
    fonts = _extract_text_fonts(tx_body)
    sizes = _extract_text_sizes(tx_body)
    return {
        "paragraphs": len(paragraphs),
        "runs": len(runs),
        "colors": colors,
        "fonts": fonts,
        "sizes_pt": sizes,
        "has_lstStyle": tx_body.find("a:lstStyle", NS) is not None,
    }


def _extract_fill(node: ET.Element) -> dict[str, Any] | None:
    solid = node.find("a:solidFill", NS)
    if solid is not None:
        return {"type": "solid", "color": _extract_color(solid)}

    grad = node.find("a:gradFill", NS)
    if grad is not None:
        stops = []
        for gs in grad.findall("a:gsLst/a:gs", NS):
            stops.append({"pos": gs.attrib.get("pos"), "color": _extract_color(gs)})
        return {"type": "gradient", "stops": stops}

    blip = node.find("a:blipFill", NS)
    if blip is not None:
        return {"type": "image"}

    patt = node.find("a:pattFill", NS)
    if patt is not None:
        return {"type": "pattern", "colors": _extract_color_nodes(patt)}

    if node.find("a:noFill", NS) is not None:
        return {"type": "none"}

    return None


def _extract_color_nodes(node: ET.Element) -> list[dict[str, Any]]:
    colors = []
    for tag in ["srgbClr", "schemeClr", "sysClr", "prstClr"]:
        for color in node.findall(f".//a:{tag}", NS):
            entry = {"kind": tag, "value": color.attrib.get("val")}
            if tag == "sysClr" and "lastClr" in color.attrib:
                entry["lastClr"] = color.attrib.get("lastClr")
            colors.append(entry)
    return colors


def _extract_color(node: ET.Element) -> dict[str, Any] | None:
    for tag in ["srgbClr", "schemeClr", "sysClr", "prstClr"]:
        child = node.find(f"a:{tag}", NS)
        if child is None:
            continue
        entry = {"kind": tag, "value": child.attrib.get("val")}
        if tag == "sysClr" and "lastClr" in child.attrib:
            entry["lastClr"] = child.attrib.get("lastClr")
        return entry
    return None


def _local_name(tag: str) -> str:
    if "}" in tag:
        return tag.split("}", 1)[1]
    return tag


def _part_basename(part: str | None) -> str | None:
    if not part:
        return None
    return posixpath.basename(part)


def _extract_text_fonts(tx_body: ET.Element) -> list[dict[str, Any]]:
    counts: dict[str, int] = {}
    for rpr in tx_body.findall(".//a:rPr", NS) + tx_body.findall(".//a:defRPr", NS):
        latin = rpr.find("a:latin", NS)
        if latin is None:
            continue
        font = latin.attrib.get("typeface")
        if not font:
            continue
        counts[font] = counts.get(font, 0) + 1
    return [{"value": key, "count": count} for key, count in sorted(counts.items())]


def _extract_text_sizes(tx_body: ET.Element) -> list[dict[str, Any]]:
    counts: dict[float, int] = {}
    for rpr in tx_body.findall(".//a:rPr", NS) + tx_body.findall(".//a:defRPr", NS):
        raw = rpr.attrib.get("sz")
        if not raw or not raw.isdigit():
            continue
        pt = int(raw) / 100
        counts[pt] = counts.get(pt, 0) + 1
    return [
        {"value": size, "count": count}
        for size, count in sorted(counts.items(), key=lambda item: item[0])
    ]


def _summarize_layer(layer: dict[str, Any]) -> dict[str, Any]:
    shapes = layer.get("shapes", [])
    all_shapes = list(_iter_shapes(shapes))
    bg = "none"
    bg_data = layer.get("background") or {}
    bg_fill = bg_data.get("fill")
    if bg_fill:
        bg = _format_fill(bg_fill)

    shape_fill_hard = 0
    shape_fill_theme = 0
    text_color_hard = 0
    text_color_theme = 0
    fonts: dict[str, int] = {}
    sizes: set[float] = set()

    for shape in all_shapes:
        fill = shape.get("fill")
        if fill and fill.get("color"):
            kind = fill["color"].get("kind")
            if kind == "schemeClr":
                shape_fill_theme += 1
            elif kind:
                shape_fill_hard += 1

        text = shape.get("text")
        if not text:
            continue
        for color in text.get("colors", []):
            kind = color.get("kind")
            if kind == "schemeClr":
                text_color_theme += 1
            elif kind:
                text_color_hard += 1
        for font in text.get("fonts", []):
            value = font.get("value")
            count = int(font.get("count", 0))
            if value:
                fonts[value] = fonts.get(value, 0) + count
        for size in text.get("sizes_pt", []):
            value = size.get("value")
            if isinstance(value, (int, float)):
                sizes.add(float(value))

    font_list = [f"{name}({count})" for name, count in sorted(fonts.items())]
    sizes_list = ", ".join(str(int(s) if s.is_integer() else s) for s in sorted(sizes))
    sizes_text = f"{{{sizes_list}}}" if sizes_list else "{}"

    clrmap = "yes" if layer.get("has_clrMap") else "no"
    if layer.get("has_clrMapOvr"):
        clrmap = "override"

    return {
        "bg": bg,
        "shape_fill_hard": shape_fill_hard,
        "shape_fill_theme": shape_fill_theme,
        "text_color_hard": text_color_hard,
        "text_color_theme": text_color_theme,
        "fonts": font_list,
        "sizes": sizes_text,
        "clrmap": clrmap,
    }


def _slide_has_local_hardcoded(slide: dict[str, Any]) -> bool:
    local = slide.get("local") or {}
    bg = local.get("background") or {}
    if _has_hardcoded_fill(bg.get("fill")):
        return True

    for shape in _iter_shapes(local.get("shapes", [])):
        if _has_hardcoded_fill(shape.get("fill")):
            return True
        text = shape.get("text") or {}
        for color in text.get("colors", []):
            kind = color.get("kind")
            if kind and kind != "schemeClr":
                return True
    return False


def _iter_shapes(shapes: Iterable[dict[str, Any]]) -> Iterable[dict[str, Any]]:
    for shape in shapes:
        yield shape
        if shape.get("type") == "group":
            for child in _iter_shapes(shape.get("children", [])):
                yield child


def _format_fill(fill: dict[str, Any]) -> str:
    if not fill:
        return "none"
    if fill.get("type") == "solid":
        color = fill.get("color")
        if not color:
            return "solid"
        kind = color.get("kind")
        val = color.get("value")
        if kind == "schemeClr":
            return f"scheme({val})"
        if kind == "srgbClr":
            return f"srgb(#{val})"
        if kind == "sysClr":
            last = color.get("lastClr")
            suffix = f"/{last}" if last else ""
            return f"sys({val}{suffix})"
        return f"{kind}({val})"
    return fill.get("type", "none")


def _has_hardcoded_fill(fill: dict[str, Any] | None) -> bool:
    if not fill:
        return False
    fill_type = fill.get("type")
    if fill_type == "solid":
        color = fill.get("color") or {}
        kind = color.get("kind")
        return bool(kind and kind != "schemeClr")
    if fill_type == "gradient":
        for stop in fill.get("stops", []):
            color = stop.get("color") or {}
            kind = color.get("kind")
            if kind and kind != "schemeClr":
                return True
        return False
    if fill_type == "pattern":
        for color in fill.get("colors", []):
            kind = color.get("kind")
            if kind and kind != "schemeClr":
                return True
        return False
    return False



================================================
FILE: src/potxkit/formatting.py
================================================
from __future__ import annotations

import xml.etree.ElementTree as ET

A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
NS = {"a": A_NS, "p": P_NS}

SCHEME_SYNONYMS = {
    "dark1": "dk1",
    "light1": "lt1",
    "dark2": "dk2",
    "light2": "lt2",
}


def apply_color_mapping(root: ET.Element, mapping: dict[str, str]) -> int:
    normalized = normalize_mapping(mapping)
    replacements = 0
    for parent in root.iter():
        children = list(parent)
        for index, child in enumerate(children):
            if child.tag != f"{{{A_NS}}}srgbClr":
                continue
            raw = child.attrib.get("val", "")
            if not raw:
                continue
            key = raw.strip().lstrip("#").upper()
            if key not in normalized:
                continue
            scheme_val = normalized[key]
            scheme = ET.Element(f"{{{A_NS}}}schemeClr", {"val": scheme_val})
            scheme.extend(list(child))
            scheme.text = child.text
            scheme.tail = child.tail
            parent.remove(child)
            parent.insert(index, scheme)
            replacements += 1
    return replacements


def strip_hardcoded_colors(root: ET.Element) -> int:
    removed = 0
    parent_map = _parent_map(root)
    for node in list(root.iter()):
        if node.tag in {f"{{{A_NS}}}srgbClr", f"{{{A_NS}}}sysClr"}:
            parent = parent_map.get(node)
            if parent is not None:
                parent.remove(node)
                removed += 1

    for node in root.findall(".//p:clrMapOvr", NS):
        parent = parent_map.get(node)
        if parent is not None:
            parent.remove(node)
            removed += 1

    for solid in root.findall(".//a:solidFill", NS):
        if not _has_color_child(solid):
            parent = parent_map.get(solid)
            if parent is not None:
                parent.remove(solid)

    for gs in root.findall(".//a:gs", NS):
        if not _has_color_child(gs):
            parent = parent_map.get(gs)
            if parent is not None:
                parent.remove(gs)

    return removed


def strip_inline_formatting(root: ET.Element) -> int:
    removed = 0
    parent_map = _parent_map(root)
    for tag in [
        f"{{{A_NS}}}rPr",
        f"{{{A_NS}}}defRPr",
        f"{{{A_NS}}}lstStyle",
        f"{{{A_NS}}}buClr",
        f"{{{A_NS}}}buSz",
        f"{{{A_NS}}}buFont",
        f"{{{A_NS}}}buChar",
        f"{{{A_NS}}}buAutoNum",
    ]:
        for node in root.findall(f".//{tag}"):
            parent = parent_map.get(node)
            if parent is not None:
                parent.remove(node)
                removed += 1
    return removed


def set_text_font_family(root: ET.Element, typeface: str) -> int:
    updated = 0
    for tag in ["rPr", "defRPr"]:
        for node in root.findall(f".//a:{tag}", NS):
            latin = node.find("a:latin", NS)
            if latin is None:
                latin = ET.SubElement(node, f"{{{A_NS}}}latin")
            latin.set("typeface", typeface)
            updated += 1
    return updated


def normalize_mapping(mapping: dict[str, str]) -> dict[str, str]:
    normalized: dict[str, str] = {}
    for key, value in mapping.items():
        color = key.strip().lstrip("#").upper()
        scheme = value.strip()
        scheme = SCHEME_SYNONYMS.get(scheme.lower(), scheme)
        normalized[color] = scheme
    return normalized


def _parent_map(root: ET.Element) -> dict[ET.Element, ET.Element]:
    return {child: parent for parent in root.iter() for child in list(parent)}


def _has_color_child(node: ET.Element) -> bool:
    for child in list(node):
        if child.tag in {
            f"{{{A_NS}}}srgbClr",
            f"{{{A_NS}}}schemeClr",
            f"{{{A_NS}}}sysClr",
            f"{{{A_NS}}}prstClr",
        }:
            return True
    return False



================================================
FILE: src/potxkit/layout_ops.py
================================================
from __future__ import annotations

import copy
import posixpath
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Iterable

from .content_types import ensure_override, remove_override
from .formatting import (
    apply_color_mapping,
    set_text_font_family,
    strip_hardcoded_colors,
    strip_inline_formatting,
)
from .media import add_image_part
from .package import OOXMLPackage
from .rels import (
    Relationship,
    ensure_relationship,
    parse_relationships,
    rels_part_for,
    serialize_relationships,
)
from .slide_index import slide_parts_in_order
from .typography import set_layout_text_styles, set_master_text_styles

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
R_NS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"

NS = {"p": P_NS, "a": A_NS, "r": R_NS}

SLIDE_LAYOUT_REL = (
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout"
)
SLIDE_MASTER_REL = (
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster"
)
IMAGE_REL = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"
SLIDE_LAYOUT_CONTENT_TYPE = (
    "application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"
)


def make_layout_from_slide(
    pkg: OOXMLPackage,
    slide_number: int,
    name: str,
    master_index: int = 1,
) -> str:
    slide_parts = slide_parts_in_order(pkg)
    if slide_number < 1 or slide_number > len(slide_parts):
        raise ValueError("Slide number out of range")

    master_part = _master_part_by_index(pkg, master_index)
    template_layout = _first_layout_for_master(pkg, master_part)

    slide_part = slide_parts[slide_number - 1]
    slide_root = ET.fromstring(pkg.read_part(slide_part))
    layout_root = ET.fromstring(pkg.read_part(template_layout))

    slide_c_sld = slide_root.find("p:cSld", NS)
    layout_c_sld = layout_root.find("p:cSld", NS)
    if slide_c_sld is None or layout_c_sld is None:
        raise ValueError("Slide or layout is missing cSld")

    parent_map = {
        child: parent for parent in layout_root.iter() for child in list(parent)
    }
    layout_parent = parent_map.get(layout_c_sld)
    if layout_parent is None:
        raise ValueError("Failed to locate layout cSld parent")

    layout_parent.remove(layout_c_sld)
    layout_parent.insert(0, copy.deepcopy(slide_c_sld))

    layout_root.set("name", name)

    new_layout_part = _next_layout_part(pkg)
    pkg.write_part(
        new_layout_part,
        ET.tostring(layout_root, encoding="utf-8", xml_declaration=True),
    )

    layout_rels = _layout_relationships_from_slide(
        pkg, slide_part, master_part, new_layout_part
    )
    pkg.write_part(rels_part_for(new_layout_part), serialize_relationships(layout_rels))

    master_rel_target = _rel_target(master_part, new_layout_part)
    rel = ensure_relationship(pkg, master_part, SLIDE_LAYOUT_REL, master_rel_target)
    _insert_layout_id(master_part, pkg, rel.id)

    ensure_override(pkg, f"/{new_layout_part}", SLIDE_LAYOUT_CONTENT_TYPE)

    return new_layout_part


def assign_slides_to_layout(
    pkg: OOXMLPackage, slide_numbers: Iterable[int], layout_part: str
) -> None:
    slide_parts = slide_parts_in_order(pkg)
    for number in slide_numbers:
        if number < 1 or number > len(slide_parts):
            raise ValueError("Slide number out of range")
        slide_part = slide_parts[number - 1]
        _set_slide_layout(pkg, slide_part, layout_part)


def apply_palette_to_part(pkg: OOXMLPackage, part: str, mapping: dict[str, str]) -> int:
    root = ET.fromstring(pkg.read_part(part))
    replacements = apply_color_mapping(root, mapping)
    if replacements:
        pkg.write_part(part, ET.tostring(root, encoding="utf-8", xml_declaration=True))
    return replacements


def strip_colors_from_part(pkg: OOXMLPackage, part: str) -> int:
    root = ET.fromstring(pkg.read_part(part))
    removed = strip_hardcoded_colors(root)
    if removed:
        pkg.write_part(part, ET.tostring(root, encoding="utf-8", xml_declaration=True))
    return removed


def strip_fonts_from_part(pkg: OOXMLPackage, part: str) -> int:
    root = ET.fromstring(pkg.read_part(part))
    removed = strip_inline_formatting(root)
    if removed:
        pkg.write_part(part, ET.tostring(root, encoding="utf-8", xml_declaration=True))
    return removed


def set_font_family_for_part(pkg: OOXMLPackage, part: str, font: str) -> int:
    root = ET.fromstring(pkg.read_part(part))
    updated = set_text_font_family(root, font)
    if updated:
        pkg.write_part(part, ET.tostring(root, encoding="utf-8", xml_declaration=True))
    return updated


def set_layout_background_image(
    pkg: OOXMLPackage, layout_part: str, image_path: str
) -> None:
    image_part = add_image_part(pkg, image_path)
    target = _rel_target(layout_part, image_part)
    rel = ensure_relationship(pkg, layout_part, IMAGE_REL, target)

    root = ET.fromstring(pkg.read_part(layout_part))
    c_sld = root.find("p:cSld", NS)
    if c_sld is None:
        raise ValueError("Layout missing cSld")

    bg = c_sld.find("p:bg", NS)
    if bg is None:
        bg = ET.SubElement(c_sld, f"{{{P_NS}}}bg")
    for child in list(bg):
        bg.remove(child)

    bg_pr = ET.SubElement(bg, f"{{{P_NS}}}bgPr")
    blip_fill = ET.SubElement(bg_pr, f"{{{A_NS}}}blipFill")
    blip = ET.SubElement(blip_fill, f"{{{A_NS}}}blip")
    blip.set(f"{{{R_NS}}}embed", rel.id)
    stretch = ET.SubElement(blip_fill, f"{{{A_NS}}}stretch")
    ET.SubElement(stretch, f"{{{A_NS}}}fillRect")

    pkg.write_part(
        layout_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
    )


def add_layout_image_shape(
    pkg: OOXMLPackage,
    layout_part: str,
    image_path: str,
    x: int,
    y: int,
    cx: int,
    cy: int,
    name: str | None = None,
) -> None:
    image_part = add_image_part(pkg, image_path)
    target = _rel_target(layout_part, image_part)
    rel = ensure_relationship(pkg, layout_part, IMAGE_REL, target)

    root = ET.fromstring(pkg.read_part(layout_part))
    sp_tree = root.find("p:cSld/p:spTree", NS)
    if sp_tree is None:
        raise ValueError("Layout missing spTree")

    next_id = _next_shape_id(sp_tree)
    pic = ET.SubElement(sp_tree, f"{{{P_NS}}}pic")
    nv_pic_pr = ET.SubElement(pic, f"{{{P_NS}}}nvPicPr")
    c_nv_pr = ET.SubElement(nv_pic_pr, f"{{{P_NS}}}cNvPr")
    c_nv_pr.set("id", str(next_id))
    c_nv_pr.set("name", name or f"Picture {next_id}")
    ET.SubElement(nv_pic_pr, f"{{{P_NS}}}cNvPicPr")
    ET.SubElement(nv_pic_pr, f"{{{P_NS}}}nvPr")

    blip_fill = ET.SubElement(pic, f"{{{P_NS}}}blipFill")
    blip = ET.SubElement(blip_fill, f"{{{A_NS}}}blip")
    blip.set(f"{{{R_NS}}}embed", rel.id)
    stretch = ET.SubElement(blip_fill, f"{{{A_NS}}}stretch")
    ET.SubElement(stretch, f"{{{A_NS}}}fillRect")

    sp_pr = ET.SubElement(pic, f"{{{P_NS}}}spPr")
    xfrm = ET.SubElement(sp_pr, f"{{{A_NS}}}xfrm")
    ET.SubElement(xfrm, f"{{{A_NS}}}off", {"x": str(x), "y": str(y)})
    ET.SubElement(xfrm, f"{{{A_NS}}}ext", {"cx": str(cx), "cy": str(cy)})
    prst = ET.SubElement(sp_pr, f"{{{A_NS}}}prstGeom", {"prst": "rect"})
    ET.SubElement(prst, f"{{{A_NS}}}avLst")

    pkg.write_part(
        layout_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
    )


def set_layout_text_styles_for_part(
    pkg: OOXMLPackage,
    layout_part: str,
    title_size_pt: float | None,
    title_bold: bool | None,
    body_size_pt: float | None,
    body_bold: bool | None,
) -> int:
    root = ET.fromstring(pkg.read_part(layout_part))
    updated = set_layout_text_styles(
        root, title_size_pt, title_bold, body_size_pt, body_bold
    )
    if updated:
        pkg.write_part(
            layout_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
        )
    return updated


def set_master_text_styles_for_part(
    pkg: OOXMLPackage,
    master_part: str,
    title_size_pt: float | None,
    title_bold: bool | None,
    body_size_pt: float | None,
    body_bold: bool | None,
) -> int:
    root = ET.fromstring(pkg.read_part(master_part))
    updated = set_master_text_styles(
        root, title_size_pt, title_bold, body_size_pt, body_bold
    )
    if updated:
        pkg.write_part(
            master_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
        )
    return updated


def resolve_layout_part(pkg: OOXMLPackage, selector: str) -> str:
    if selector.startswith("ppt/slideLayouts/"):
        if not pkg.has_part(selector):
            raise ValueError(f"Layout not found: {selector}")
        return selector

    if selector.isdigit():
        index = int(selector)
        layouts = _layout_parts(pkg)
        if index < 1 or index > len(layouts):
            raise ValueError("Layout index out of range")
        return layouts[index - 1]

    for part in _layout_parts(pkg):
        root = ET.fromstring(pkg.read_part(part))
        name = root.attrib.get("name")
        if name == selector:
            return part

    raise ValueError(f"Layout not found: {selector}")


def resolve_master_part(pkg: OOXMLPackage, selector: str) -> str:
    if selector.startswith("ppt/slideMasters/"):
        if not pkg.has_part(selector):
            raise ValueError(f"Master not found: {selector}")
        return selector
    if selector.isdigit():
        return _master_part_by_index(pkg, int(selector))
    raise ValueError(f"Master not found: {selector}")


def _set_slide_layout(pkg: OOXMLPackage, slide_part: str, layout_part: str) -> None:
    rels_part = rels_part_for(slide_part)
    if not pkg.has_part(rels_part):
        raise ValueError(f"Missing relationships for slide: {slide_part}")
    relationships = parse_relationships(pkg.read_part(rels_part))
    updated = False
    target = _rel_target(slide_part, layout_part)
    for rel in relationships:
        if rel.type == SLIDE_LAYOUT_REL:
            rel.target = target
            updated = True
            break
    if not updated:
        relationships.append(
            Relationship(
                id=_next_rid(relationships), type=SLIDE_LAYOUT_REL, target=target
            )
        )
    pkg.write_part(rels_part, serialize_relationships(relationships))


def _layout_parts(pkg: OOXMLPackage) -> list[str]:
    return sorted(
        [
            p
            for p in pkg.list_parts()
            if p.startswith("ppt/slideLayouts/") and p.endswith(".xml")
        ]
    )


def _master_part_by_index(pkg: OOXMLPackage, index: int) -> str:
    masters = sorted(
        [
            p
            for p in pkg.list_parts()
            if p.startswith("ppt/slideMasters/") and p.endswith(".xml")
        ]
    )
    if not masters:
        raise ValueError("No slide master parts found")
    if index < 1 or index > len(masters):
        raise ValueError("Master index out of range")
    return masters[index - 1]


def _first_layout_for_master(pkg: OOXMLPackage, master_part: str) -> str:
    rels_part = rels_part_for(master_part)
    relationships = parse_relationships(pkg.read_part(rels_part))
    for rel in relationships:
        if rel.type == SLIDE_LAYOUT_REL:
            return _resolve_target(posixpath.dirname(master_part), rel.target)
    layouts = _layout_parts(pkg)
    if not layouts:
        raise ValueError("No slide layout parts found")
    return layouts[0]


def _layout_relationships_from_slide(
    pkg: OOXMLPackage, slide_part: str, master_part: str, layout_part: str
) -> list[Relationship]:
    rels_part = rels_part_for(slide_part)
    slide_rels = parse_relationships(pkg.read_part(rels_part))
    embed_ids = _slide_embed_ids(pkg.read_part(slide_part))

    layout_rels = [rel for rel in slide_rels if rel.id in embed_ids]

    master_target = _rel_target(layout_part, master_part)
    master_id = _next_rid(layout_rels)
    layout_rels.append(
        Relationship(id=master_id, type=SLIDE_MASTER_REL, target=master_target)
    )
    return layout_rels


def _slide_embed_ids(xml_bytes: bytes) -> set[str]:
    root = ET.fromstring(xml_bytes)
    ids = set()
    for node in root.iter():
        for attr in ("embed", "link", "id"):
            rid = node.attrib.get(f"{{{R_NS}}}{attr}")
            if rid:
                ids.add(rid)
    return ids


def _insert_layout_id(master_part: str, pkg: OOXMLPackage, rel_id: str) -> None:
    root = ET.fromstring(pkg.read_part(master_part))
    layout_list = root.find("p:sldLayoutIdLst", NS)
    if layout_list is None:
        layout_list = ET.SubElement(root, f"{{{P_NS}}}sldLayoutIdLst")

    max_id = 0
    for sld_layout_id in layout_list.findall("p:sldLayoutId", NS):
        raw = sld_layout_id.attrib.get("id")
        if raw and raw.isdigit():
            max_id = max(max_id, int(raw))

    new_id = str(max_id + 1 if max_id else 256)
    attrib = {"id": new_id, f"{{{R_NS}}}id": rel_id}
    ET.SubElement(layout_list, f"{{{P_NS}}}sldLayoutId", attrib)

    pkg.write_part(
        master_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
    )


def _next_layout_part(pkg: OOXMLPackage) -> str:
    numbers = []
    for part in _layout_parts(pkg):
        name = posixpath.basename(part)
        if name.startswith("slideLayout") and name.endswith(".xml"):
            raw = name.removeprefix("slideLayout").removesuffix(".xml")
            if raw.isdigit():
                numbers.append(int(raw))
    next_index = max(numbers) + 1 if numbers else 1
    return f"ppt/slideLayouts/slideLayout{next_index}.xml"


def _rel_target(source_part: str, target_part: str) -> str:
    source_dir = posixpath.dirname(source_part)
    return posixpath.relpath(target_part, start=source_dir)


def _resolve_target(base_dir: str, target: str) -> str:
    if target.startswith("/"):
        return target[1:]
    return posixpath.normpath(posixpath.join(base_dir, target))


def _next_rid(relationships: list[Relationship]) -> str:
    existing = {rel.id for rel in relationships}
    idx = 1
    while f"rId{idx}" in existing:
        idx += 1
    return f"rId{idx}"


def slide_size(pkg: OOXMLPackage) -> tuple[int, int]:
    if not pkg.has_part("ppt/presentation.xml"):
        return (0, 0)
    root = ET.fromstring(pkg.read_part("ppt/presentation.xml"))
    sld_sz = root.find("p:sldSz", NS)
    if sld_sz is None:
        return (0, 0)
    cx = int(sld_sz.attrib.get("cx", "0"))
    cy = int(sld_sz.attrib.get("cy", "0"))
    return (cx, cy)


def _next_shape_id(sp_tree: ET.Element) -> int:
    max_id = 0
    for c_nv_pr in sp_tree.findall(".//p:cNvPr", NS):
        raw = c_nv_pr.attrib.get("id")
        if raw and raw.isdigit():
            max_id = max(max_id, int(raw))
    return max_id + 1


@dataclass
class PruneLayoutsResult:
    removed_layouts: list[str]
    unused_layouts: list[str]
    masters_updated: int


@dataclass
class ReindexLayoutsResult:
    layout_mapping: dict[str, str]
    masters_updated: int
    slides_updated: int


def prune_unused_layouts(
    pkg: OOXMLPackage, *, keep_layouts: set[str] | None = None
) -> PruneLayoutsResult:
    keep = keep_layouts or set()
    slide_parts = slide_parts_in_order(pkg)
    used_layouts: set[str] = set()
    for slide_part in slide_parts:
        layout_part = _slide_layout_part(pkg, slide_part)
        if layout_part:
            used_layouts.add(layout_part)

    layout_parts = _layout_parts(pkg)
    unused = [
        layout
        for layout in layout_parts
        if layout not in used_layouts and layout not in keep
    ]

    masters_updated = 0
    for layout in unused:
        masters_updated += _remove_layout_from_masters(pkg, layout)
        pkg.delete_part(layout)
        rels_part = rels_part_for(layout)
        if pkg.has_part(rels_part):
            pkg.delete_part(rels_part)
        remove_override(pkg, layout)

    return PruneLayoutsResult(
        removed_layouts=unused, unused_layouts=unused, masters_updated=masters_updated
    )


def reindex_layouts(pkg: OOXMLPackage) -> ReindexLayoutsResult:
    mapping = _build_layout_reindex_map(pkg)
    if not mapping:
        return ReindexLayoutsResult(
            layout_mapping={}, masters_updated=0, slides_updated=0
        )

    _rename_layout_parts(pkg, mapping)
    slides_updated = _update_slide_layout_relationships(pkg, mapping)
    masters_updated = _reindex_master_layouts(pkg, mapping)

    return ReindexLayoutsResult(
        layout_mapping=mapping,
        masters_updated=masters_updated,
        slides_updated=slides_updated,
    )


def _build_layout_reindex_map(pkg: OOXMLPackage) -> dict[str, str]:
    layout_parts = _layout_parts(pkg)
    if not layout_parts:
        return {}

    mapping: dict[str, str] = {}
    for master_part in _master_parts(pkg):
        order = _master_layout_order(pkg, master_part)
        if not order:
            continue
        for idx, layout_part in enumerate(order, start=1):
            new_name = f"ppt/slideLayouts/slideLayout{idx}.xml"
            if layout_part in mapping and mapping[layout_part] != new_name:
                raise ValueError(
                    f"Layout {layout_part} already mapped to {mapping[layout_part]}"
                )
            mapping[layout_part] = new_name

    return mapping


def _rename_layout_parts(pkg: OOXMLPackage, mapping: dict[str, str]) -> None:
    if not mapping:
        return

    temp_mapping: dict[str, str] = {}
    counter = 1
    for old, new in mapping.items():
        if old == new:
            continue
        temp = f"ppt/slideLayouts/_tmpLayout{counter}.xml"
        while pkg.has_part(temp) or temp in temp_mapping.values():
            counter += 1
            temp = f"ppt/slideLayouts/_tmpLayout{counter}.xml"
        temp_mapping[old] = temp
        counter += 1

    for old, temp in temp_mapping.items():
        pkg.write_part(temp, pkg.read_part(old))
        pkg.delete_part(old)
        old_rels = rels_part_for(old)
        if pkg.has_part(old_rels):
            temp_rels = rels_part_for(temp)
            pkg.write_part(temp_rels, pkg.read_part(old_rels))
            pkg.delete_part(old_rels)
        remove_override(pkg, old)

    for old, new in mapping.items():
        if old == new:
            ensure_override(pkg, new, SLIDE_LAYOUT_CONTENT_TYPE)
            continue
        temp = temp_mapping[old]
        pkg.write_part(new, pkg.read_part(temp))
        pkg.delete_part(temp)
        temp_rels = rels_part_for(temp)
        if pkg.has_part(temp_rels):
            new_rels = rels_part_for(new)
            pkg.write_part(new_rels, pkg.read_part(temp_rels))
            pkg.delete_part(temp_rels)
        ensure_override(pkg, new, SLIDE_LAYOUT_CONTENT_TYPE)


def _update_slide_layout_relationships(
    pkg: OOXMLPackage, mapping: dict[str, str]
) -> int:
    updated = 0
    for slide_part in slide_parts_in_order(pkg):
        rels_part = rels_part_for(slide_part)
        if not pkg.has_part(rels_part):
            continue
        rels = parse_relationships(pkg.read_part(rels_part))
        changed = False
        for rel in rels:
            if not rel.type.endswith("/slideLayout"):
                continue
            target = _resolve_target(posixpath.dirname(slide_part), rel.target)
            if target in mapping:
                rel.target = _rel_target(slide_part, mapping[target])
                changed = True
        if changed:
            pkg.write_part(rels_part, serialize_relationships(rels))
            updated += 1
    return updated


def _reindex_master_layouts(pkg: OOXMLPackage, mapping: dict[str, str]) -> int:
    updated = 0
    for master_part in _master_parts(pkg):
        order = _master_layout_order(pkg, master_part)
        if not order:
            continue

        rels_part = rels_part_for(master_part)
        rels = (
            parse_relationships(pkg.read_part(rels_part))
            if pkg.has_part(rels_part)
            else []
        )
        non_layout = [rel for rel in rels if not rel.type.endswith("/slideLayout")]
        used_ids = {rel.id for rel in non_layout}

        new_layout_rels: list[Relationship] = []
        next_idx = 1
        for layout_part in order:
            new_part = mapping.get(layout_part, layout_part)
            while f"rId{next_idx}" in used_ids:
                next_idx += 1
            rel_id = f"rId{next_idx}"
            used_ids.add(rel_id)
            next_idx += 1
            target = _rel_target(master_part, new_part)
            new_layout_rels.append(
                Relationship(id=rel_id, type=SLIDE_LAYOUT_REL, target=target)
            )

        new_rels = non_layout + new_layout_rels
        pkg.write_part(rels_part, serialize_relationships(new_rels))

        root = ET.fromstring(pkg.read_part(master_part))
        layout_list = root.find("p:sldLayoutIdLst", NS)
        if layout_list is not None:
            for node, layout_rel in zip(
                layout_list.findall("p:sldLayoutId", NS), new_layout_rels
            ):
                node.set(f"{{{R_NS}}}id", layout_rel.id)
        pkg.write_part(
            master_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
        )
        updated += 1
    return updated


def _master_layout_order(pkg: OOXMLPackage, master_part: str) -> list[str]:
    rels_part = rels_part_for(master_part)
    if not pkg.has_part(rels_part):
        return []
    rels = parse_relationships(pkg.read_part(rels_part))
    rel_map = {rel.id: rel for rel in rels}

    root = ET.fromstring(pkg.read_part(master_part))
    layout_list = root.find("p:sldLayoutIdLst", NS)
    if layout_list is None:
        return []

    order: list[str] = []
    for node in layout_list.findall("p:sldLayoutId", NS):
        rid = node.attrib.get(f"{{{R_NS}}}id")
        rel = rel_map.get(rid)
        if rel is None:
            continue
        target = _resolve_target(posixpath.dirname(master_part), rel.target)
        if target:
            order.append(target)
    return order


def _slide_layout_part(pkg: OOXMLPackage, slide_part: str) -> str | None:
    rels_part = rels_part_for(slide_part)
    if not pkg.has_part(rels_part):
        return None
    relationships = parse_relationships(pkg.read_part(rels_part))
    for rel in relationships:
        if rel.type.endswith("/slideLayout"):
            return _resolve_target(posixpath.dirname(slide_part), rel.target)
    return None


def _master_parts(pkg: OOXMLPackage) -> list[str]:
    return sorted(
        [
            p
            for p in pkg.list_parts()
            if p.startswith("ppt/slideMasters/") and p.endswith(".xml")
        ]
    )


def _remove_layout_from_masters(pkg: OOXMLPackage, layout_part: str) -> int:
    updated = 0
    for master_part in _master_parts(pkg):
        rels_part = rels_part_for(master_part)
        if not pkg.has_part(rels_part):
            continue
        relationships = parse_relationships(pkg.read_part(rels_part))
        keep_rels: list[Relationship] = []
        removed_ids: set[str] = set()
        for rel in relationships:
            if rel.type.endswith("/slideLayout"):
                target = _resolve_target(posixpath.dirname(master_part), rel.target)
                if target == layout_part:
                    removed_ids.add(rel.id)
                    continue
            keep_rels.append(rel)

        if not removed_ids:
            continue

        pkg.write_part(rels_part, serialize_relationships(keep_rels))

        root = ET.fromstring(pkg.read_part(master_part))
        layout_list = root.find("p:sldLayoutIdLst", NS)
        if layout_list is not None:
            for layout_id in list(layout_list.findall("p:sldLayoutId", NS)):
                rid = layout_id.attrib.get(f"{{{R_NS}}}id")
                if rid in removed_ids:
                    layout_list.remove(layout_id)
        pkg.write_part(
            master_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
        )
        updated += 1
    return updated



================================================
FILE: src/potxkit/mcp_server.py
================================================
from __future__ import annotations

import json
from dataclasses import asdict
from typing import Any

from fastmcp import FastMCP

from .audit import audit_package
from .dump_tree import DumpTreeOptions, summarize_tree
from .dump_tree import dump_tree as _dump_tree
from .layout_ops import (
    add_layout_image_shape,
    apply_palette_to_part,
    assign_slides_to_layout,
    make_layout_from_slide,
    prune_unused_layouts,
    resolve_layout_part,
    resolve_master_part,
    set_font_family_for_part,
    set_layout_background_image,
    set_layout_text_styles_for_part,
    set_master_text_styles_for_part,
    slide_size,
    strip_colors_from_part,
    strip_fonts_from_part,
)
from .layout_ops import (
    reindex_layouts as _reindex_layouts,
)
from .normalize import normalize_slide_colors, parse_slide_numbers
from .package import OOXMLPackage
from .sanitize import sanitize_slides
from .slide_index import slide_parts_in_order
from .storage import read_bytes, write_bytes
from .template import PotxTemplate

mcp = FastMCP("potxkit")


def _parse_group_by(value: str) -> list[str]:
    if not value:
        return ["p", "l"]
    parts = [item.strip() for item in value.split(",") if item.strip()]
    valid = {"p", "b", "l"}
    for item in parts:
        if item not in valid:
            raise ValueError("group_by must be a comma list of p,b,l (e.g. p,b,l)")
    return parts


def _load_pkg(path: str) -> OOXMLPackage:
    return OOXMLPackage(read_bytes(path))


def _save_pkg(pkg: OOXMLPackage, output: str) -> str:
    write_bytes(output, pkg.save_bytes())
    return output


@mcp.tool()
def info(path: str) -> dict[str, Any]:
    """Return theme colors, fonts, and validation status for a .pptx/.potx."""
    tpl = PotxTemplate.open(path)
    colors = tpl.theme.colors.as_dict()
    fonts = tpl.theme.fonts
    major = fonts.get_major()
    minor = fonts.get_minor()
    report = tpl.validate()
    return {
        "colors": colors,
        "fonts": {
            "major": major.latin if major else None,
            "minor": minor.latin if minor else None,
        },
        "validation": {
            "ok": report.ok,
            "errors": report.errors,
            "warnings": report.warnings,
        },
    }


@mcp.tool()
def validate(path: str) -> dict[str, Any]:
    """Validate a .pptx/.potx and return errors/warnings."""
    tpl = PotxTemplate.open(path)
    report = tpl.validate()
    return {"ok": report.ok, "errors": report.errors, "warnings": report.warnings}


@mcp.tool()
def dump_theme(path: str, pretty: bool = False) -> str:
    """Dump theme colors/fonts as JSON."""
    tpl = PotxTemplate.open(path)
    payload: dict[str, Any] = dict(tpl.theme.colors.as_dict())
    fonts = tpl.theme.fonts
    major = fonts.get_major()
    minor = fonts.get_minor()
    if major:
        payload["majorFont"] = major.latin
    if minor:
        payload["minorFont"] = minor.latin
    return json.dumps(payload, indent=2 if pretty else None)


@mcp.tool()
def audit(
    path: str, slides: str | None = None, group_by: str = "p,l"
) -> dict[str, Any]:
    """Audit slides for hard-coded colors, overrides, images, and backgrounds."""
    pkg = _load_pkg(path)
    slide_numbers = parse_slide_numbers(slides) if slides else None
    report = audit_package(pkg, slide_numbers, group_by=_parse_group_by(group_by))
    return {
        "theme": report.theme,
        "masters": report.masters,
        "layouts": report.layouts,
        "slides": report.slides,
        "groups": report.groups,
    }


@mcp.tool()
def dump_tree(
    path: str,
    slides: str | None = None,
    grouped: bool = False,
    include_layout: bool = False,
    include_master: bool = False,
    include_text: bool = False,
    summary: bool = False,
) -> dict[str, Any]:
    """Dump a hierarchical view of slides; use summary=true for compact output."""
    pkg = _load_pkg(path)
    slide_numbers = parse_slide_numbers(slides) if slides else None
    if grouped and not include_layout and not include_master:
        include_layout = True
        include_master = True
    options = DumpTreeOptions(
        include_layout=include_layout,
        include_master=include_master,
        include_text=include_text,
        grouped=grouped,
    )
    payload = _dump_tree(pkg, slide_numbers=slide_numbers, options=options)
    if summary:
        return {"summary": summarize_tree(payload)}
    return payload


@mcp.tool()
def normalize(
    input_path: str,
    output: str,
    mapping: dict[str, str],
    slides: str | None = None,
) -> dict[str, Any]:
    """Replace hard-coded colors with theme scheme colors using a mapping."""
    pkg = _load_pkg(input_path)
    slide_numbers = parse_slide_numbers(slides) if slides else None
    result = normalize_slide_colors(pkg, mapping, slide_numbers)
    _save_pkg(pkg, output)
    return asdict(result)


@mcp.tool()
def set_colors(
    input_path: str | None,
    output: str,
    colors: dict[str, str],
) -> str:
    """Set theme color slots (dk1, lt1, accent1, etc.)."""
    tpl = PotxTemplate.open(input_path) if input_path else PotxTemplate.new()
    theme_colors = tpl.theme.colors
    for key, value in colors.items():
        if key in {"dark1", "dk1"}:
            theme_colors.set_dark1(value)
        elif key in {"light1", "lt1"}:
            theme_colors.set_light1(value)
        elif key in {"dark2", "dk2"}:
            theme_colors.set_dark2(value)
        elif key in {"light2", "lt2"}:
            theme_colors.set_light2(value)
        elif key.startswith("accent") and key[6:].isdigit():
            theme_colors.set_accent(int(key[6:]), value)
        elif key == "hlink":
            theme_colors.set_hyperlink(value)
        elif key == "folHlink":
            theme_colors.set_followed_hyperlink(value)
    tpl.save(output)
    return output


@mcp.tool()
def set_fonts(
    input_path: str | None,
    output: str,
    major: str | None = None,
    minor: str | None = None,
) -> str:
    """Set major/minor theme fonts."""
    tpl = PotxTemplate.open(input_path) if input_path else PotxTemplate.new()
    fonts = tpl.theme.fonts
    if major:
        fonts.set_major(major)
    if minor:
        fonts.set_minor(minor)
    tpl.save(output)
    return output


@mcp.tool()
def set_theme_names(
    input_path: str | None,
    output: str,
    theme: str | None = None,
    colors: str | None = None,
    fonts: str | None = None,
) -> str:
    """Set theme, color scheme, and font scheme names for PowerPoint UI."""
    tpl = PotxTemplate.open(input_path) if input_path else PotxTemplate.new()
    if theme:
        tpl.theme.set_name(theme)
    if colors:
        tpl.theme.set_color_scheme_name(colors)
    if fonts:
        tpl.theme.set_font_scheme_name(fonts)
    tpl.save(output)
    return output


@mcp.tool()
def make_layout(
    input_path: str,
    output: str,
    from_slide: int,
    name: str,
    master_index: int = 1,
    assign_slides: str | None = None,
) -> dict[str, Any]:
    """Create a slide layout from a slide and optionally reassign slides to it."""
    pkg = _load_pkg(input_path)
    layout_part = make_layout_from_slide(pkg, from_slide, name, master_index)
    if assign_slides:
        slides = parse_slide_numbers(assign_slides)
        assign_slides_to_layout(pkg, slides, layout_part)
    _save_pkg(pkg, output)
    return {"output": output, "layout_part": layout_part}


@mcp.tool()
def set_layout(
    input_path: str,
    output: str,
    layout: str,
    palette: dict[str, str] | None = None,
    palette_none: bool = False,
    font: str | None = None,
    fonts_none: bool = False,
) -> str:
    """Update a layout's palette or fonts (or strip overrides)."""
    pkg = _load_pkg(input_path)
    layout_part = resolve_layout_part(pkg, layout)
    if palette:
        apply_palette_to_part(pkg, layout_part, palette)
    if palette_none:
        strip_colors_from_part(pkg, layout_part)
    if font:
        set_font_family_for_part(pkg, layout_part, font)
    if fonts_none:
        strip_fonts_from_part(pkg, layout_part)
    _save_pkg(pkg, output)
    return output


@mcp.tool()
def set_master(
    input_path: str,
    output: str,
    master: str = "1",
    palette: dict[str, str] | None = None,
    palette_none: bool = False,
    font: str | None = None,
    fonts_none: bool = False,
) -> str:
    """Update a slide master palette or fonts (or strip overrides)."""
    pkg = _load_pkg(input_path)
    master_part = resolve_master_part(pkg, master)
    if palette:
        apply_palette_to_part(pkg, master_part, palette)
    if palette_none:
        strip_colors_from_part(pkg, master_part)
    if font:
        set_font_family_for_part(pkg, master_part, font)
    if fonts_none:
        strip_fonts_from_part(pkg, master_part)
    _save_pkg(pkg, output)
    return output


@mcp.tool()
def set_slide(
    input_path: str,
    output: str,
    slides: str,
    layout: str | None = None,
    palette: dict[str, str] | None = None,
    palette_none: bool = False,
    font: str | None = None,
    fonts_none: bool = False,
) -> str:
    """Update slide-level palette/fonts and optionally reassign layouts."""
    pkg = _load_pkg(input_path)
    slide_numbers = parse_slide_numbers(slides)
    parts = slide_parts_in_order(pkg)
    slide_parts = []
    for num in sorted(slide_numbers):
        if num < 1 or num > len(parts):
            raise ValueError("Slide number out of range")
        slide_parts.append(parts[num - 1])

    for slide_part in slide_parts:
        if palette:
            apply_palette_to_part(pkg, slide_part, palette)
        if palette_none:
            strip_colors_from_part(pkg, slide_part)
        if font:
            set_font_family_for_part(pkg, slide_part, font)
        if fonts_none:
            strip_fonts_from_part(pkg, slide_part)
    if layout:
        layout_part = resolve_layout_part(pkg, layout)
        assign_slides_to_layout(pkg, slide_numbers, layout_part)

    _save_pkg(pkg, output)
    return output


@mcp.tool()
def set_text_styles(
    input_path: str,
    output: str,
    layout: str | None = None,
    master: str | None = None,
    title_size: float | None = None,
    body_size: float | None = None,
    title_bold: bool | None = None,
    body_bold: bool | None = None,
) -> str:
    """Set title/body text sizes and bold styles on layouts or masters."""
    pkg = _load_pkg(input_path)
    if layout:
        layout_part = resolve_layout_part(pkg, layout)
        set_layout_text_styles_for_part(
            pkg, layout_part, title_size, title_bold, body_size, body_bold
        )
    if master:
        master_part = resolve_master_part(pkg, master)
        set_master_text_styles_for_part(
            pkg, master_part, title_size, title_bold, body_size, body_bold
        )
    _save_pkg(pkg, output)
    return output


@mcp.tool()
def set_layout_bg(input_path: str, output: str, layout: str, image: str) -> str:
    """Set a layout background image."""
    pkg = _load_pkg(input_path)
    layout_part = resolve_layout_part(pkg, layout)
    set_layout_background_image(pkg, layout_part, image)
    _save_pkg(pkg, output)
    return output


@mcp.tool()
def set_layout_image(
    input_path: str,
    output: str,
    layout: str,
    image: str,
    x: float | None = None,
    y: float | None = None,
    w: float | None = None,
    h: float | None = None,
    units: str = "in",
    name: str | None = None,
) -> str:
    """Add an image layer to a layout (x/y/w/h in inches unless units=emu)."""
    pkg = _load_pkg(input_path)
    layout_part = resolve_layout_part(pkg, layout)
    cx, cy = slide_size(pkg)
    if units == "emu":
        x_emu = int(x or 0)
        y_emu = int(y or 0)
        w_emu = int(w if w is not None else cx)
        h_emu = int(h if h is not None else cy)
    else:
        factor = 914400
        x_emu = int((x or 0) * factor)
        y_emu = int((y or 0) * factor)
        w_emu = int((w if w is not None else (cx / factor)) * factor)
        h_emu = int((h if h is not None else (cy / factor)) * factor)
    add_layout_image_shape(pkg, layout_part, image, x_emu, y_emu, w_emu, h_emu, name)
    _save_pkg(pkg, output)
    return output


@mcp.tool()
def auto_layout(
    input_path: str,
    output: str,
    group_by: str = "p,l",
    prefix: str = "Auto Layout",
    master_index: int = 1,
    assign: bool = True,
    strip_colors: bool = False,
    strip_fonts: bool = False,
    palette: dict[str, str] | None = None,
) -> dict[str, Any]:
    """Auto-generate layouts by grouping slides and optionally strip overrides."""
    pkg = _load_pkg(input_path)
    from .auto_layout import auto_layout as _auto

    result = _auto(
        pkg,
        group_by=_parse_group_by(group_by),
        prefix=prefix,
        master_index=master_index,
        assign=assign,
        strip_colors=strip_colors,
        strip_fonts=strip_fonts,
        palette=palette,
    )
    _save_pkg(pkg, output)
    return {"output": output, "layouts_created": len(result.created_layouts)}


@mcp.tool()
def prune_layouts(input_path: str, output: str) -> dict[str, Any]:
    """Remove unused slide layouts and update master references."""
    pkg = _load_pkg(input_path)
    result = prune_unused_layouts(pkg)
    _save_pkg(pkg, output)
    return {"output": output, "removed": len(result.removed_layouts)}


@mcp.tool()
def reindex_layouts(input_path: str, output: str) -> dict[str, Any]:
    """Renumber layouts and update slide/master references."""
    pkg = _load_pkg(input_path)
    result = _reindex_layouts(pkg)
    _save_pkg(pkg, output)
    return {"output": output, "layout_mapping": result.layout_mapping}


@mcp.tool()
def sanitize(input_path: str, output: str, slides: str | None = None) -> dict[str, Any]:
    """Insert missing clrMapOvr, lstStyle, and bg/noFill to avoid repair prompts."""
    pkg = _load_pkg(input_path)
    slide_numbers = parse_slide_numbers(slides) if slides else None
    result = sanitize_slides(pkg, slide_numbers)
    _save_pkg(pkg, output)
    return asdict(result)


def main() -> None:
    """Run the potxkit MCP server over stdio."""
    mcp.run()



================================================
FILE: src/potxkit/media.py
================================================
from __future__ import annotations

from pathlib import Path

from .content_types import ensure_default
from .package import OOXMLPackage

IMAGE_TYPES = {
    "png": "image/png",
    "jpg": "image/jpeg",
    "jpeg": "image/jpeg",
    "gif": "image/gif",
    "bmp": "image/bmp",
}


def add_image_part(pkg: OOXMLPackage, image_path: str) -> str:
    path = Path(image_path)
    if not path.exists():
        raise FileNotFoundError(image_path)
    ext = path.suffix.lower().lstrip(".")
    if ext not in IMAGE_TYPES:
        raise ValueError(f"Unsupported image type: {ext}")

    part_name = _next_media_part(pkg, ext)
    pkg.write_part(part_name, path.read_bytes())
    ensure_default(pkg, ext, IMAGE_TYPES[ext])
    return part_name


def _next_media_part(pkg: OOXMLPackage, ext: str) -> str:
    numbers = []
    for part in pkg.list_parts():
        if not part.startswith("ppt/media/"):
            continue
        name = Path(part).name
        if name.startswith("image") and name.endswith(f".{ext}"):
            raw = name.removeprefix("image").removesuffix(f".{ext}")
            if raw.isdigit():
                numbers.append(int(raw))
    next_index = max(numbers) + 1 if numbers else 1
    return f"ppt/media/image{next_index}.{ext}"



================================================
FILE: src/potxkit/normalize.py
================================================
from __future__ import annotations

import xml.etree.ElementTree as ET
from dataclasses import dataclass

from .formatting import apply_color_mapping, normalize_mapping
from .package import OOXMLPackage
from .slide_index import slide_parts_in_order

SCHEME_SYNONYMS = {
    "dark1": "dk1",
    "light1": "lt1",
    "dark2": "dk2",
    "light2": "lt2",
}


@dataclass
class NormalizeResult:
    slides_total: int
    slides_touched: int
    replacements: int
    per_slide: dict[int, int]


def normalize_slide_colors(
    pkg: OOXMLPackage,
    mapping: dict[str, str],
    slide_numbers: set[int] | None = None,
) -> NormalizeResult:
    slide_parts = slide_parts_in_order(pkg)
    normalized_mapping = normalize_mapping(mapping)

    per_slide: dict[int, int] = {}
    total_replacements = 0
    touched = 0

    for idx, slide_part in enumerate(slide_parts, start=1):
        if slide_numbers and idx not in slide_numbers:
            continue
        root = ET.fromstring(pkg.read_part(slide_part))
        replacements = apply_color_mapping(root, normalized_mapping)
        if replacements:
            pkg.write_part(
                slide_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
            )
            total_replacements += replacements
            per_slide[idx] = replacements
            touched += 1

    return NormalizeResult(
        slides_total=len(slide_parts),
        slides_touched=touched,
        replacements=total_replacements,
        per_slide=per_slide,
    )


def parse_slide_numbers(value: str) -> set[int]:
    if not value:
        return set()
    selections: set[int] = set()
    for token in value.split(","):
        token = token.strip()
        if not token:
            continue
        if "-" in token:
            start_str, end_str = token.split("-", 1)
            start = int(start_str)
            end = int(end_str)
            if start <= 0 or end <= 0:
                raise ValueError("Slide numbers must be positive")
            if end < start:
                start, end = end, start
            selections.update(range(start, end + 1))
        else:
            num = int(token)
            if num <= 0:
                raise ValueError("Slide numbers must be positive")
            selections.add(num)
    return selections



================================================
FILE: src/potxkit/package.py
================================================
from __future__ import annotations

import io
import zipfile
from dataclasses import dataclass
from typing import Iterable


@dataclass(frozen=True)
class PackagePart:
    name: str
    data: bytes


class OOXMLPackage:
    def __init__(self, data: bytes) -> None:
        self._parts: dict[str, bytes] = {}
        self._order: list[str] = []
        self._load(data)

    def _load(self, data: bytes) -> None:
        with zipfile.ZipFile(io.BytesIO(data), "r") as zin:
            for info in zin.infolist():
                self._order.append(info.filename)
                self._parts[info.filename] = zin.read(info.filename)

    def list_parts(self) -> list[str]:
        return list(self._parts.keys())

    def has_part(self, name: str) -> bool:
        return self._normalize_name(name) in self._parts

    def read_part(self, name: str) -> bytes:
        key = self._normalize_name(name)
        if key not in self._parts:
            raise KeyError(f"Part not found: {name}")
        return self._parts[key]

    def write_part(self, name: str, data: bytes) -> None:
        key = self._normalize_name(name)
        if key not in self._parts:
            self._order.append(key)
        self._parts[key] = data

    def delete_part(self, name: str) -> None:
        key = self._normalize_name(name)
        if key in self._parts:
            del self._parts[key]
        self._order = [entry for entry in self._order if entry != key]

    def iter_parts(self) -> Iterable[PackagePart]:
        for name in self._order:
            if name in self._parts:
                yield PackagePart(name=name, data=self._parts[name])

    def save_bytes(self) -> bytes:
        out = io.BytesIO()
        with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
            written = set()
            for part in self.iter_parts():
                zout.writestr(part.name, part.data)
                written.add(part.name)
            for name, data in self._parts.items():
                if name not in written:
                    zout.writestr(name, data)
        return out.getvalue()

    @staticmethod
    def _normalize_name(name: str) -> str:
        if name.startswith("/"):
            return name[1:]
        return name



================================================
FILE: src/potxkit/rels.py
================================================
from __future__ import annotations

import posixpath
import xml.etree.ElementTree as ET
from dataclasses import dataclass

from .package import OOXMLPackage

REL_NS = "http://schemas.openxmlformats.org/package/2006/relationships"


@dataclass
class Relationship:
    id: str
    type: str
    target: str
    target_mode: str | None = None


def rels_part_for(source_part: str) -> str:
    source = _strip_leading_slash(source_part)
    if source == "":
        return "_rels/.rels"
    source_dir = posixpath.dirname(source)
    source_base = posixpath.basename(source)
    return posixpath.join(source_dir, "_rels", f"{source_base}.rels")


def source_part_for(rels_part: str) -> str:
    rels = _strip_leading_slash(rels_part)
    if rels == "_rels/.rels":
        return ""
    rels_dir = posixpath.dirname(rels)
    source_dir = posixpath.dirname(rels_dir)
    source_base = posixpath.basename(rels).removesuffix(".rels")
    return posixpath.join(source_dir, source_base)


def parse_relationships(xml_bytes: bytes) -> list[Relationship]:
    root = ET.fromstring(xml_bytes)
    relationships = []
    for rel in root.findall(f"{{{REL_NS}}}Relationship"):
        relationships.append(
            Relationship(
                id=rel.attrib.get("Id", ""),
                type=rel.attrib.get("Type", ""),
                target=rel.attrib.get("Target", ""),
                target_mode=rel.attrib.get("TargetMode"),
            )
        )
    return relationships


def serialize_relationships(relationships: list[Relationship]) -> bytes:
    root = ET.Element(f"{{{REL_NS}}}Relationships")
    for rel in relationships:
        attrib = {"Id": rel.id, "Type": rel.type, "Target": rel.target}
        if rel.target_mode:
            attrib["TargetMode"] = rel.target_mode
        ET.SubElement(root, f"{{{REL_NS}}}Relationship", attrib)
    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


def get_relationships(pkg: OOXMLPackage, source_part: str) -> list[Relationship]:
    rels_part = rels_part_for(source_part)
    if not pkg.has_part(rels_part):
        return []
    return parse_relationships(pkg.read_part(rels_part))


def write_relationships(
    pkg: OOXMLPackage, source_part: str, relationships: list[Relationship]
) -> None:
    rels_part = rels_part_for(source_part)
    pkg.write_part(rels_part, serialize_relationships(relationships))


def ensure_relationship(
    pkg: OOXMLPackage, source_part: str, rel_type: str, target: str
) -> Relationship:
    relationships = get_relationships(pkg, source_part)
    for rel in relationships:
        if rel.type == rel_type and rel.target == target:
            return rel

    next_id = _next_rid(relationships)
    new_rel = Relationship(id=next_id, type=rel_type, target=target)
    relationships.append(new_rel)
    write_relationships(pkg, source_part, relationships)
    return new_rel


def _next_rid(relationships: list[Relationship]) -> str:
    existing = {rel.id for rel in relationships}
    index = 1
    while f"rId{index}" in existing:
        index += 1
    return f"rId{index}"


def _strip_leading_slash(path: str) -> str:
    return path[1:] if path.startswith("/") else path



================================================
FILE: src/potxkit/resources.py
================================================
from __future__ import annotations

from importlib import resources


def load_base_template() -> bytes:
    return resources.files("potxkit.data").joinpath("base.potx").read_bytes()



================================================
FILE: src/potxkit/sanitize.py
================================================
from __future__ import annotations

import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Iterable

from .package import OOXMLPackage
from .slide_index import slide_parts_in_order

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
NS = {"p": P_NS, "a": A_NS}


@dataclass
class SanitizeResult:
    slides_updated: int
    clrmap_added: int
    lststyle_added: int
    bg_nofill_added: int


def sanitize_slides(
    pkg: OOXMLPackage, slide_numbers: Iterable[int] | None = None
) -> SanitizeResult:
    slide_parts = slide_parts_in_order(pkg)
    if slide_numbers is not None:
        requested = {num for num in slide_numbers}
        selected = []
        for num in sorted(requested):
            if num < 1 or num > len(slide_parts):
                raise ValueError("Slide number out of range")
            selected.append(slide_parts[num - 1])
        slide_parts = selected

    slides_updated = 0
    clrmap_added = 0
    lststyle_added = 0
    bg_nofill_added = 0

    for slide_part in slide_parts:
        root = ET.fromstring(pkg.read_part(slide_part))
        changed = False

        if _ensure_clrmap_ovr(root):
            clrmap_added += 1
            changed = True
        lst_added = _ensure_lststyle(root)
        if lst_added:
            lststyle_added += lst_added
            changed = True
        if _ensure_bg_nofill(root):
            bg_nofill_added += 1
            changed = True

        if changed:
            pkg.write_part(
                slide_part, ET.tostring(root, encoding="utf-8", xml_declaration=True)
            )
            slides_updated += 1

    return SanitizeResult(
        slides_updated=slides_updated,
        clrmap_added=clrmap_added,
        lststyle_added=lststyle_added,
        bg_nofill_added=bg_nofill_added,
    )


def _ensure_clrmap_ovr(root: ET.Element) -> bool:
    if root.find("p:clrMapOvr", NS) is not None:
        return False
    clrmap = ET.Element(f"{{{P_NS}}}clrMapOvr")
    ET.SubElement(clrmap, f"{{{A_NS}}}masterClrMapping")

    transition = root.find("p:transition", NS)
    if transition is not None:
        root.insert(list(root).index(transition), clrmap)
    else:
        root.append(clrmap)
    return True


def _ensure_lststyle(root: ET.Element) -> int:
    added = 0
    for tx_body in root.findall(".//p:txBody", NS):
        if tx_body.find("a:lstStyle", NS) is not None:
            continue
        lst = ET.Element(f"{{{A_NS}}}lstStyle")
        body_pr = tx_body.find("a:bodyPr", NS)
        if body_pr is not None:
            tx_body.insert(list(tx_body).index(body_pr) + 1, lst)
        else:
            tx_body.insert(0, lst)
        added += 1
    return added


def _ensure_bg_nofill(root: ET.Element) -> int:
    bg_pr = root.find("p:cSld/p:bg/p:bgPr", NS)
    if bg_pr is None:
        return 0
    for tag in ["a:solidFill", "a:gradFill", "a:blipFill", "a:pattFill", "a:noFill"]:
        if bg_pr.find(tag, NS) is not None:
            return 0
    no_fill = ET.Element(f"{{{A_NS}}}noFill")
    effect = bg_pr.find("a:effectLst", NS)
    if effect is not None:
        bg_pr.insert(list(bg_pr).index(effect), no_fill)
    else:
        bg_pr.append(no_fill)
    return 1



================================================
FILE: src/potxkit/slide_index.py
================================================
from __future__ import annotations

import posixpath
import xml.etree.ElementTree as ET

from .package import OOXMLPackage

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
R_NS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
REL_NS = "http://schemas.openxmlformats.org/package/2006/relationships"

NS = {"p": P_NS, "r": R_NS}


def slide_parts_in_order(pkg: OOXMLPackage) -> list[str]:
    if not pkg.has_part("ppt/presentation.xml") or not pkg.has_part(
        "ppt/_rels/presentation.xml.rels"
    ):
        return _fallback_slide_parts(pkg)

    presentation = ET.fromstring(pkg.read_part("ppt/presentation.xml"))
    rels = _read_rels(pkg, "ppt/_rels/presentation.xml.rels")

    slide_parts = []
    for sld_id in presentation.findall("p:sldIdLst/p:sldId", NS):
        rid = sld_id.attrib.get(f"{{{R_NS}}}id")
        if not rid or rid not in rels:
            continue
        rel_type, target = rels[rid]
        if not rel_type.endswith("/slide"):
            continue
        slide_parts.append(_resolve_target("ppt", target))

    return slide_parts or _fallback_slide_parts(pkg)


def _fallback_slide_parts(pkg: OOXMLPackage) -> list[str]:
    return sorted(
        [
            p
            for p in pkg.list_parts()
            if p.startswith("ppt/slides/slide") and p.endswith(".xml")
        ]
    )


def _read_rels(pkg: OOXMLPackage, rels_part: str) -> dict[str, tuple[str, str]]:
    if not pkg.has_part(rels_part):
        return {}
    root = ET.fromstring(pkg.read_part(rels_part))
    rels: dict[str, tuple[str, str]] = {}
    for rel in root.findall(f"{{{REL_NS}}}Relationship"):
        rid = rel.attrib.get("Id")
        if not rid:
            continue
        rels[rid] = (rel.attrib.get("Type", ""), rel.attrib.get("Target", ""))
    return rels


def _resolve_target(base_dir: str, target: str) -> str:
    if target.startswith("/"):
        return target[1:]
    return posixpath.normpath(posixpath.join(base_dir, target))



================================================
FILE: src/potxkit/storage.py
================================================
from __future__ import annotations

from typing import Any

import fsspec


def read_bytes(uri: str, *, fs_kwargs: dict[str, Any] | None = None) -> bytes:
    fs_kwargs = fs_kwargs or {}
    with fsspec.open(uri, "rb", **fs_kwargs) as handle:
        return handle.read()


def write_bytes(
    uri: str, data: bytes, *, fs_kwargs: dict[str, Any] | None = None
) -> None:
    fs_kwargs = fs_kwargs or {}
    with fsspec.open(uri, "wb", **fs_kwargs) as handle:
        handle.write(data)



================================================
FILE: src/potxkit/template.py
================================================
from __future__ import annotations

import posixpath
from dataclasses import dataclass
from typing import Any

from .content_types import ensure_override
from .package import OOXMLPackage
from .rels import ensure_relationship
from .resources import load_base_template
from .storage import read_bytes, write_bytes
from .theme import Theme
from .validate import ValidationReport, validate_package

THEME_REL_TYPE = (
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme"
)
THEME_CONTENT_TYPE = "application/vnd.openxmlformats-officedocument.theme+xml"


@dataclass
class PotxTemplate:
    _package: OOXMLPackage
    _theme_path: str
    _theme: Theme | None = None

    @classmethod
    def open(
        cls, uri: str, *, fs_kwargs: dict[str, Any] | None = None
    ) -> "PotxTemplate":
        data = read_bytes(uri, fs_kwargs=fs_kwargs)
        pkg = OOXMLPackage(data)
        theme_path = _find_theme_part(pkg)
        return cls(pkg, theme_path)

    @classmethod
    def new(cls) -> "PotxTemplate":
        data = load_base_template()
        pkg = OOXMLPackage(data)
        theme_path = _find_theme_part(pkg)
        return cls(pkg, theme_path)

    @property
    def theme(self) -> Theme:
        if self._theme is None:
            self._theme = Theme.from_bytes(self._package.read_part(self._theme_path))
        return self._theme

    def save(self, uri: str, *, fs_kwargs: dict[str, Any] | None = None) -> None:
        if self._theme is not None:
            self._package.write_part(self._theme_path, self._theme.to_bytes())
        self._ensure_theme_relationship()
        ensure_override(self._package, f"/{self._theme_path}", THEME_CONTENT_TYPE)
        write_bytes(uri, self._package.save_bytes(), fs_kwargs=fs_kwargs)

    def validate(self) -> ValidationReport:
        return validate_package(self._package, self._theme_path)

    def _ensure_theme_relationship(self) -> None:
        if not self._package.has_part("ppt/presentation.xml"):
            return
        source_part = "ppt/presentation.xml"
        target = _rel_target(source_part, self._theme_path)
        ensure_relationship(self._package, source_part, THEME_REL_TYPE, target)


def _find_theme_part(pkg: OOXMLPackage) -> str:
    candidates = [
        name
        for name in pkg.list_parts()
        if name.startswith("ppt/theme/") and name.endswith(".xml")
    ]
    if not candidates:
        raise KeyError("No theme part found in package")
    if "ppt/theme/theme1.xml" in candidates:
        return "ppt/theme/theme1.xml"
    return sorted(candidates)[0]


def _rel_target(source_part: str, target_part: str) -> str:
    source_dir = posixpath.dirname(source_part)
    return posixpath.relpath(target_part, start=source_dir)



================================================
FILE: src/potxkit/theme.py
================================================
from __future__ import annotations

import re
import xml.etree.ElementTree as ET
from dataclasses import dataclass

A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
NS = {"a": A_NS}
ET.register_namespace("a", A_NS)


@dataclass
class ThemeFontSpec:
    latin: str
    east_asian: str | None = None
    complex_script: str | None = None


class ThemeColors:
    def __init__(self, clr_scheme: ET.Element) -> None:
        self._clr_scheme = clr_scheme

    def get_dark1(self) -> str | None:
        return self._get_slot_hex("dk1")

    def get_light1(self) -> str | None:
        return self._get_slot_hex("lt1")

    def get_dark2(self) -> str | None:
        return self._get_slot_hex("dk2")

    def get_light2(self) -> str | None:
        return self._get_slot_hex("lt2")

    def get_accent(self, index: int) -> str | None:
        return self._get_slot_hex(f"accent{index}")

    def get_hyperlink(self) -> str | None:
        return self._get_slot_hex("hlink")

    def get_followed_hyperlink(self) -> str | None:
        return self._get_slot_hex("folHlink")

    def set_dark1(self, value: str) -> None:
        self._set_slot_hex("dk1", value)

    def set_light1(self, value: str) -> None:
        self._set_slot_hex("lt1", value)

    def set_dark2(self, value: str) -> None:
        self._set_slot_hex("dk2", value)

    def set_light2(self, value: str) -> None:
        self._set_slot_hex("lt2", value)

    def set_accent(self, index: int, value: str) -> None:
        self._set_slot_hex(f"accent{index}", value)

    def set_hyperlink(self, value: str) -> None:
        self._set_slot_hex("hlink", value)

    def set_followed_hyperlink(self, value: str) -> None:
        self._set_slot_hex("folHlink", value)

    def as_dict(self) -> dict[str, str | None]:
        slots = [
            "dk1",
            "lt1",
            "dk2",
            "lt2",
            "accent1",
            "accent2",
            "accent3",
            "accent4",
            "accent5",
            "accent6",
            "hlink",
            "folHlink",
        ]
        return {slot: self._get_slot_hex(slot) for slot in slots}

    def _get_slot_hex(self, name: str) -> str | None:
        slot = self._clr_scheme.find(f"a:{name}", NS)
        if slot is None:
            return None
        srgb = slot.find("a:srgbClr", NS)
        if srgb is not None and srgb.attrib.get("val"):
            return f"#{srgb.attrib['val'].upper()}"
        sysclr = slot.find("a:sysClr", NS)
        if sysclr is not None and sysclr.attrib.get("lastClr"):
            return f"#{sysclr.attrib['lastClr'].upper()}"
        return None

    def _set_slot_hex(self, name: str, value: str) -> None:
        slot = self._clr_scheme.find(f"a:{name}", NS)
        if slot is None:
            slot = ET.SubElement(self._clr_scheme, f"{{{A_NS}}}{name}")
        for child in list(slot):
            slot.remove(child)
        srgb = ET.SubElement(slot, f"{{{A_NS}}}srgbClr")
        srgb.set("val", _normalize_hex(value))


class ThemeFonts:
    def __init__(self, font_scheme: ET.Element) -> None:
        self._font_scheme = font_scheme

    def get_major(self) -> ThemeFontSpec | None:
        return self._get_font_spec("majorFont")

    def get_minor(self) -> ThemeFontSpec | None:
        return self._get_font_spec("minorFont")

    def set_major(
        self,
        latin: str,
        east_asian: str | None = None,
        complex_script: str | None = None,
    ) -> None:
        self._set_font_spec("majorFont", latin, east_asian, complex_script)

    def set_minor(
        self,
        latin: str,
        east_asian: str | None = None,
        complex_script: str | None = None,
    ) -> None:
        self._set_font_spec("minorFont", latin, east_asian, complex_script)

    def _get_font_spec(self, name: str) -> ThemeFontSpec | None:
        node = self._font_scheme.find(f"a:{name}", NS)
        if node is None:
            return None
        latin = node.find("a:latin", NS)
        if latin is None:
            return None
        ea = node.find("a:ea", NS)
        cs = node.find("a:cs", NS)
        return ThemeFontSpec(
            latin=latin.attrib.get("typeface", ""),
            east_asian=ea.attrib.get("typeface") if ea is not None else None,
            complex_script=cs.attrib.get("typeface") if cs is not None else None,
        )

    def _set_font_spec(
        self,
        name: str,
        latin: str,
        east_asian: str | None,
        complex_script: str | None,
    ) -> None:
        node = self._font_scheme.find(f"a:{name}", NS)
        if node is None:
            node = ET.SubElement(self._font_scheme, f"{{{A_NS}}}{name}")
        _set_font_child(node, "latin", latin)
        if east_asian is not None:
            _set_font_child(node, "ea", east_asian)
        if complex_script is not None:
            _set_font_child(node, "cs", complex_script)


class Theme:
    def __init__(self, root: ET.Element) -> None:
        self._root = root
        theme_elements = root.find("a:themeElements", NS)
        if theme_elements is None:
            raise ValueError("Theme is missing themeElements")
        clr_scheme = theme_elements.find("a:clrScheme", NS)
        font_scheme = theme_elements.find("a:fontScheme", NS)
        if clr_scheme is None:
            raise ValueError("Theme is missing clrScheme")
        if font_scheme is None:
            raise ValueError("Theme is missing fontScheme")
        self._clr_scheme = clr_scheme
        self._font_scheme = font_scheme
        self.colors = ThemeColors(clr_scheme)
        self.fonts = ThemeFonts(font_scheme)

    @classmethod
    def from_bytes(cls, xml_bytes: bytes) -> "Theme":
        root = ET.fromstring(xml_bytes)
        return cls(root)

    def to_bytes(self) -> bytes:
        return ET.tostring(self._root, encoding="utf-8", xml_declaration=True)

    def get_name(self) -> str | None:
        return self._root.attrib.get("name")

    def set_name(self, value: str) -> None:
        self._root.set("name", value)

    def get_color_scheme_name(self) -> str | None:
        return self._clr_scheme.attrib.get("name")

    def set_color_scheme_name(self, value: str) -> None:
        self._clr_scheme.set("name", value)

    def get_font_scheme_name(self) -> str | None:
        return self._font_scheme.attrib.get("name")

    def set_font_scheme_name(self, value: str) -> None:
        self._font_scheme.set("name", value)


def _normalize_hex(value: str) -> str:
    value = value.strip().lstrip("#")
    if not re.fullmatch(r"[0-9a-fA-F]{6}", value):
        raise ValueError(f"Invalid hex color: {value}")
    return value.upper()


def _set_font_child(node: ET.Element, tag: str, typeface: str) -> None:
    child = node.find(f"a:{tag}", NS)
    if child is None:
        child = ET.SubElement(node, f"{{{A_NS}}}{tag}")
    child.set("typeface", typeface)



================================================
FILE: src/potxkit/typography.py
================================================
from __future__ import annotations

import xml.etree.ElementTree as ET
from collections import Counter
from dataclasses import dataclass
from typing import Any

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"

NS = {"p": P_NS, "a": A_NS}

TITLE_TYPES = {"title", "ctrTitle"}
BODY_TYPES = {"body"}


@dataclass
class TextStyleStats:
    size_counts: dict[str, int]
    bold_counts: dict[str, int]


def extract_text_style_stats(root: ET.Element) -> TextStyleStats:
    sizes: Counter[str] = Counter()
    bold: Counter[str] = Counter()

    for node in root.findall(".//a:rPr", NS) + root.findall(".//a:defRPr", NS):
        sz = node.attrib.get("sz")
        if sz and sz.isdigit():
            sizes[sz] += 1
        bold_flag = node.attrib.get("b")
        if bold_flag is not None:
            bold[bold_flag] += 1

    return TextStyleStats(size_counts=dict(sizes), bold_counts=dict(bold))


def detect_placeholder_styles(root: ET.Element) -> dict[str, dict[str, Any]]:
    styles: dict[str, dict[str, Any]] = {}
    for shape in root.findall(".//p:sp", NS):
        ph = shape.find("p:nvSpPr/p:nvPr/p:ph", NS)
        if ph is None:
            continue
        ph_type = ph.attrib.get("type", "body")
        category = (
            "title"
            if ph_type in TITLE_TYPES
            else "body" if ph_type in BODY_TYPES else None
        )
        if category is None:
            continue
        sizes = []
        bolds = []
        for rpr in shape.findall(".//a:rPr", NS) + shape.findall(".//a:defRPr", NS):
            sz = rpr.attrib.get("sz")
            if sz and sz.isdigit():
                sizes.append(int(sz))
            b = rpr.attrib.get("b")
            if b is not None:
                bolds.append(b)
        if not sizes and not bolds:
            continue
        sizes_counter = Counter(sizes)
        bold_counter = Counter(bolds)
        styles[category] = {
            "size_pt": _sz_to_pt(_most_common(sizes_counter)),
            "bold": _most_common(bold_counter) == "1" if bold_counter else None,
        }
    return styles


def set_layout_text_styles(
    root: ET.Element,
    title_size_pt: float | None,
    title_bold: bool | None,
    body_size_pt: float | None,
    body_bold: bool | None,
) -> int:
    updated = 0
    for shape in root.findall(".//p:sp", NS):
        ph = shape.find("p:nvSpPr/p:nvPr/p:ph", NS)
        if ph is None:
            continue
        ph_type = ph.attrib.get("type", "body")
        if ph_type in TITLE_TYPES:
            updated += _apply_shape_style(shape, title_size_pt, title_bold)
        elif ph_type in BODY_TYPES:
            updated += _apply_shape_style(shape, body_size_pt, body_bold)
    return updated


def set_master_text_styles(
    root: ET.Element,
    title_size_pt: float | None,
    title_bold: bool | None,
    body_size_pt: float | None,
    body_bold: bool | None,
) -> int:
    updated = 0
    tx_styles = root.find("p:txStyles", NS)
    if tx_styles is None:
        return 0
    title_style = tx_styles.find("p:titleStyle", NS)
    body_style = tx_styles.find("p:bodyStyle", NS)

    if title_style is not None:
        updated += _apply_level_style(title_style, title_size_pt, title_bold)
    if body_style is not None:
        updated += _apply_level_style(body_style, body_size_pt, body_bold)

    return updated


def _apply_shape_style(
    shape: ET.Element, size_pt: float | None, bold: bool | None
) -> int:
    if size_pt is None and bold is None:
        return 0
    lst_style = shape.find(".//a:lstStyle", NS)
    if lst_style is None:
        tx_body = shape.find(".//a:txBody", NS)
        if tx_body is None:
            return 0
        lst_style = ET.SubElement(tx_body, f"{{{A_NS}}}lstStyle")
    lvl = lst_style.find("a:lvl1pPr", NS)
    if lvl is None:
        lvl = ET.SubElement(lst_style, f"{{{A_NS}}}lvl1pPr")
    def_rpr = lvl.find("a:defRPr", NS)
    if def_rpr is None:
        def_rpr = ET.SubElement(lvl, f"{{{A_NS}}}defRPr")
    return _set_rpr(def_rpr, size_pt, bold)


def _apply_level_style(
    container: ET.Element, size_pt: float | None, bold: bool | None
) -> int:
    lvl = container.find("a:lvl1pPr", NS)
    if lvl is None:
        lvl = ET.SubElement(container, f"{{{A_NS}}}lvl1pPr")
    def_rpr = lvl.find("a:defRPr", NS)
    if def_rpr is None:
        def_rpr = ET.SubElement(lvl, f"{{{A_NS}}}defRPr")
    return _set_rpr(def_rpr, size_pt, bold)


def _set_rpr(node: ET.Element, size_pt: float | None, bold: bool | None) -> int:
    updated = 0
    if size_pt is not None:
        node.set("sz", str(_pt_to_sz(size_pt)))
        updated += 1
    if bold is not None:
        node.set("b", "1" if bold else "0")
        updated += 1
    return updated


def _pt_to_sz(size_pt: float) -> int:
    return int(round(size_pt * 100))


def _sz_to_pt(value: int | None) -> float | None:
    if value is None:
        return None
    return value / 100


def _most_common(counter: Counter) -> Any:
    if not counter:
        return None
    return counter.most_common(1)[0][0]



================================================
FILE: src/potxkit/validate.py
================================================
from __future__ import annotations

import posixpath
from dataclasses import dataclass, field

from .content_types import has_override
from .package import OOXMLPackage
from .rels import parse_relationships, source_part_for


@dataclass
class ValidationReport:
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)

    @property
    def ok(self) -> bool:
        return not self.errors


def validate_package(pkg: OOXMLPackage, theme_path: str) -> ValidationReport:
    report = ValidationReport()
    if not pkg.has_part(theme_path):
        report.errors.append(f"Missing theme part: {theme_path}")

    if not pkg.has_part("[Content_Types].xml"):
        report.errors.append("Missing [Content_Types].xml")
    elif not has_override(pkg, theme_path):
        report.warnings.append(f"No content type override for /{theme_path}")

    _validate_relationship_targets(pkg, report)
    return report


def _validate_relationship_targets(pkg: OOXMLPackage, report: ValidationReport) -> None:
    parts = pkg.list_parts()
    rels_parts = [name for name in parts if name.endswith(".rels")]
    for rels_part in rels_parts:
        xml_bytes = pkg.read_part(rels_part)
        for rel in parse_relationships(xml_bytes):
            if rel.target_mode == "External":
                continue
            source_part = source_part_for(rels_part)
            target = _resolve_target(source_part, rel.target)
            if target and not pkg.has_part(target):
                report.errors.append(f"Missing rel target: {rels_part} -> {rel.target}")


def _resolve_target(source_part: str, target: str) -> str | None:
    if target.startswith("/"):
        return target[1:]
    if source_part == "":
        return target
    source_dir = posixpath.dirname(source_part)
    resolved = posixpath.normpath(posixpath.join(source_dir, target))
    return resolved



================================================
FILE: src/potxkit/data/__init__.py
================================================
"""Bundled package data for potxkit."""



================================================
FILE: src/potxkit/data/base.potx
================================================
[Binary file]


================================================
FILE: tests/conftest.py
================================================
from __future__ import annotations

import io
import zipfile


def build_minimal_potx(*, include_theme_rel: bool = True) -> bytes:
    theme_xml = _theme_xml()
    presentation_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:presentation xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"/>'
    )
    rels_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
    )
    if include_theme_rel:
        rels_xml += (
            '<Relationship Id="rId1" '
            'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" '
            'Target="theme/theme1.xml"/>'
        )
    rels_xml += "</Relationships>"

    content_types = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'
        '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>'
        '<Default Extension="xml" ContentType="application/xml"/>'
        '<Override PartName="/ppt/presentation.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>'
        '<Override PartName="/ppt/theme/theme1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>'
        "</Types>"
    )

    out = io.BytesIO()
    with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
        zout.writestr("ppt/theme/theme1.xml", theme_xml)
        zout.writestr("ppt/presentation.xml", presentation_xml)
        zout.writestr("ppt/_rels/presentation.xml.rels", rels_xml)
        zout.writestr("[Content_Types].xml", content_types)
    return out.getvalue()


def _theme_xml() -> str:
    return (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<a:officeStyleSheet xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" '
        'name="Test">'
        "<a:themeElements>"
        '<a:clrScheme name="Test">'
        '<a:dk1><a:srgbClr val="000000"/></a:dk1>'
        '<a:lt1><a:srgbClr val="FFFFFF"/></a:lt1>'
        '<a:dk2><a:srgbClr val="1F1F1F"/></a:dk2>'
        '<a:lt2><a:srgbClr val="EEEEEE"/></a:lt2>'
        '<a:accent1><a:srgbClr val="4472C4"/></a:accent1>'
        '<a:accent2><a:srgbClr val="ED7D31"/></a:accent2>'
        '<a:accent3><a:srgbClr val="A5A5A5"/></a:accent3>'
        '<a:accent4><a:srgbClr val="FFC000"/></a:accent4>'
        '<a:accent5><a:srgbClr val="5B9BD5"/></a:accent5>'
        '<a:accent6><a:srgbClr val="70AD47"/></a:accent6>'
        '<a:hlink><a:srgbClr val="0563C1"/></a:hlink>'
        '<a:folHlink><a:srgbClr val="954F72"/></a:folHlink>'
        "</a:clrScheme>"
        '<a:fontScheme name="Test">'
        '<a:majorFont><a:latin typeface="Calibri"/></a:majorFont>'
        '<a:minorFont><a:latin typeface="Calibri"/></a:minorFont>'
        "</a:fontScheme>"
        "</a:themeElements>"
        "</a:officeStyleSheet>"
    )



================================================
FILE: tests/test_audit.py
================================================
from __future__ import annotations

import io
import zipfile

from potxkit.audit import audit_package
from potxkit.package import OOXMLPackage

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
R_NS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"


def test_audit_selected_slides() -> None:
    data = _minimal_pptx()
    pkg = OOXMLPackage(data)

    report = audit_package(pkg, {2})
    assert report.slides_total == 2
    assert report.slides_audited == 1
    assert report.layouts == {}
    assert report.masters == {}
    assert report.groups
    assert report.group_by == ["p", "l"]

    slide = report.per_slide[2]
    assert slide["color_counts"]["scheme"] == 1
    assert slide["has_clrMapOvr"] is True


def _minimal_pptx() -> bytes:
    presentation = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:presentation xmlns:p="{P_NS}" xmlns:r="{R_NS}">'
        "<p:sldIdLst>"
        '<p:sldId id="256" r:id="rId1"/>'
        '<p:sldId id="257" r:id="rId2"/>'
        "</p:sldIdLst>"
        "</p:presentation>"
    )

    rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide1.xml"/>'
        '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide2.xml"/>'
        "</Relationships>"
    )

    slide1 = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:sld xmlns:p="{P_NS}" xmlns:a="{A_NS}">'
        "<p:cSld><p:spTree>"
        '<p:sp><p:spPr><a:solidFill><a:srgbClr val="0D0D14"/></a:solidFill></p:spPr></p:sp>'
        "</p:spTree></p:cSld></p:sld>"
    )

    slide2 = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:sld xmlns:p="{P_NS}" xmlns:a="{A_NS}">'
        "<p:cSld><p:spTree>"
        '<p:sp><p:spPr><a:solidFill><a:schemeClr val="accent1"/></a:solidFill></p:spPr></p:sp>'
        "</p:spTree></p:cSld>"
        "<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr>"
        "</p:sld>"
    )

    out = io.BytesIO()
    with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
        zout.writestr("ppt/presentation.xml", presentation)
        zout.writestr("ppt/_rels/presentation.xml.rels", rels)
        zout.writestr("ppt/slides/slide1.xml", slide1)
        zout.writestr("ppt/slides/slide2.xml", slide2)
    return out.getvalue()



================================================
FILE: tests/test_auto_layout.py
================================================
from __future__ import annotations

import io
import zipfile

from potxkit.auto_layout import auto_layout
from potxkit.package import OOXMLPackage

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
R_NS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"


def test_auto_layout_creates_layouts() -> None:
    data = _minimal_pptx()
    pkg = OOXMLPackage(data)

    result = auto_layout(pkg, group_by=["p"], prefix="Auto")
    assert result.group_count == 2
    assert len(result.created_layouts) == 2


def _minimal_pptx() -> bytes:
    presentation = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:presentation xmlns:p="{P_NS}" xmlns:r="{R_NS}">'
        "<p:sldIdLst>"
        '<p:sldId id="256" r:id="rId1"/>'
        '<p:sldId id="257" r:id="rId2"/>'
        "</p:sldIdLst>"
        "</p:presentation>"
    )

    pres_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide1.xml"/>'
        '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide2.xml"/>'
        "</Relationships>"
    )

    slide1 = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:sld xmlns:p="{P_NS}" xmlns:a="{A_NS}">'
        "<p:cSld><p:spTree>"
        '<p:sp><p:spPr><a:solidFill><a:srgbClr val="111111"/></a:solidFill></p:spPr></p:sp>'
        "</p:spTree></p:cSld></p:sld>"
    )

    slide2 = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:sld xmlns:p="{P_NS}" xmlns:a="{A_NS}">'
        "<p:cSld><p:spTree>"
        '<p:sp><p:spPr><a:solidFill><a:srgbClr val="222222"/></a:solidFill></p:spPr></p:sp>'
        "</p:spTree></p:cSld></p:sld>"
    )

    master = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:sldMaster xmlns:p="{P_NS}" xmlns:a="{A_NS}" xmlns:r="{R_NS}">'
        "<p:cSld><p:spTree/></p:cSld>"
        '<p:sldLayoutIdLst><p:sldLayoutId id="256" r:id="rId1"/></p:sldLayoutIdLst>'
        "</p:sldMaster>"
    )

    layout = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:sldLayout xmlns:p="{P_NS}" xmlns:a="{A_NS}" xmlns:r="{R_NS}">'
        "<p:cSld><p:spTree/></p:cSld></p:sldLayout>"
    )

    master_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout1.xml"/>'
        "</Relationships>"
    )

    slide_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout1.xml"/>'
        "</Relationships>"
    )

    content_types = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'
        '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>'
        '<Default Extension="xml" ContentType="application/xml"/>'
        '<Override PartName="/ppt/presentation.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>'
        '<Override PartName="/ppt/slideMasters/slideMaster1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"/>'
        '<Override PartName="/ppt/slideLayouts/slideLayout1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>'
        "</Types>"
    )

    out = io.BytesIO()
    with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
        zout.writestr("ppt/presentation.xml", presentation)
        zout.writestr("ppt/_rels/presentation.xml.rels", pres_rels)
        zout.writestr("ppt/slides/slide1.xml", slide1)
        zout.writestr("ppt/slides/slide2.xml", slide2)
        zout.writestr("ppt/slides/_rels/slide1.xml.rels", slide_rels)
        zout.writestr("ppt/slides/_rels/slide2.xml.rels", slide_rels)
        zout.writestr("ppt/slideMasters/slideMaster1.xml", master)
        zout.writestr("ppt/slideMasters/_rels/slideMaster1.xml.rels", master_rels)
        zout.writestr("ppt/slideLayouts/slideLayout1.xml", layout)
        zout.writestr("[Content_Types].xml", content_types)
    return out.getvalue()



================================================
FILE: tests/test_dump_tree.py
================================================
from __future__ import annotations

import io
import zipfile

from potxkit.dump_tree import DumpTreeOptions, dump_tree, summarize_tree
from potxkit.package import OOXMLPackage


def _build_deck() -> bytes:
    presentation_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:presentation xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
        '<p:sldIdLst><p:sldId id="256" r:id="rId1"/></p:sldIdLst>'
        "</p:presentation>"
    )
    presentation_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide1.xml"/>'
        "</Relationships>"
    )
    slide_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sld xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" '
        'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
        "<p:cSld>"
        '<p:bg><p:bgPr><a:solidFill><a:srgbClr val="FF0000"/></a:solidFill></p:bgPr></p:bg>'
        "<p:spTree>"
        "<p:sp>"
        '<p:nvSpPr><p:cNvPr id="2" name="Title"/></p:nvSpPr>'
        '<p:spPr><a:solidFill><a:schemeClr val="accent1"/></a:solidFill></p:spPr>'
        "<p:txBody>"
        "<a:bodyPr/>"
        '<a:p><a:r><a:rPr><a:solidFill><a:srgbClr val="00FF00"/></a:solidFill></a:rPr>'
        "<a:t>Hello</a:t></a:r></a:p>"
        "</p:txBody>"
        "</p:sp>"
        "</p:spTree>"
        "</p:cSld>"
        "</p:sld>"
    )
    layout_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sldLayout xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">'
        "<p:cSld><p:spTree/></p:cSld>"
        "</p:sldLayout>"
    )
    layout_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster" '
        'Target="../slideMasters/slideMaster1.xml"/>'
        "</Relationships>"
    )
    slide_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout1.xml"/>'
        "</Relationships>"
    )
    master_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sldMaster xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">'
        "<p:cSld><p:spTree/></p:cSld>"
        "</p:sldMaster>"
    )
    master_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout1.xml"/>'
        "</Relationships>"
    )
    content_types = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'
        '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>'
        '<Default Extension="xml" ContentType="application/xml"/>'
        '<Override PartName="/ppt/presentation.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>'
        '<Override PartName="/ppt/slides/slide1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slide+xml"/>'
        '<Override PartName="/ppt/slideLayouts/slideLayout1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>'
        '<Override PartName="/ppt/slideMasters/slideMaster1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"/>'
        "</Types>"
    )

    out = io.BytesIO()
    with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
        zout.writestr("ppt/presentation.xml", presentation_xml)
        zout.writestr("ppt/_rels/presentation.xml.rels", presentation_rels)
        zout.writestr("ppt/slides/slide1.xml", slide_xml)
        zout.writestr("ppt/slides/_rels/slide1.xml.rels", slide_rels)
        zout.writestr("ppt/slideLayouts/slideLayout1.xml", layout_xml)
        zout.writestr("ppt/slideLayouts/_rels/slideLayout1.xml.rels", layout_rels)
        zout.writestr("ppt/slideMasters/slideMaster1.xml", master_xml)
        zout.writestr("ppt/slideMasters/_rels/slideMaster1.xml.rels", master_rels)
        zout.writestr("[Content_Types].xml", content_types)
    return out.getvalue()


def test_dump_tree_includes_background_and_shapes() -> None:
    pkg = OOXMLPackage(_build_deck())
    payload = dump_tree(
        pkg,
        options=DumpTreeOptions(
            include_layout=True, include_master=True, include_text=True, grouped=True
        ),
    )

    slides = payload["slides"]
    assert len(slides) == 1
    slide = slides[0]
    assert slide["local"]["background"]["fill"]["type"] == "solid"
    assert slide["local"]["background"]["fill"]["color"]["value"] == "FF0000"

    shapes = slide["local"]["shapes"]
    assert shapes[0]["type"] == "shape"
    assert shapes[0]["fill"]["type"] == "solid"
    assert shapes[0]["fill"]["color"]["value"] == "accent1"
    assert shapes[0]["text"]["colors"][0]["value"] == "00FF00"

    assert slide["slideLayout"]["part"] == "ppt/slideLayouts/slideLayout1.xml"
    assert slide["slideMaster"]["part"] == "ppt/slideMasters/slideMaster1.xml"


def test_dump_tree_summary_includes_local() -> None:
    pkg = OOXMLPackage(_build_deck())
    payload = dump_tree(
        pkg,
        options=DumpTreeOptions(
            include_layout=True, include_master=True, include_text=True, grouped=True
        ),
    )
    lines = summarize_tree(payload)
    assert any(line.startswith("slide 1:") for line in lines)
    assert any("local:" in line for line in lines)


def test_dump_tree_summary_local_only_filters() -> None:
    pkg = OOXMLPackage(_build_deck())
    payload = dump_tree(
        pkg,
        options=DumpTreeOptions(
            include_layout=True, include_master=True, include_text=True, grouped=True
        ),
    )
    lines = summarize_tree(payload, local_only=True)
    assert any(line.startswith("slide 1:") for line in lines)



================================================
FILE: tests/test_formatting.py
================================================
from __future__ import annotations

import xml.etree.ElementTree as ET

from potxkit.formatting import (
    apply_color_mapping,
    set_text_font_family,
    strip_hardcoded_colors,
    strip_inline_formatting,
)

A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"


def test_apply_color_mapping() -> None:
    root = ET.fromstring(
        f'<a:solidFill xmlns:a="{A_NS}"><a:srgbClr val="FF0000"/></a:solidFill>'
    )
    assert apply_color_mapping(root, {"FF0000": "accent1"}) == 1
    assert root.find(f".//{{{A_NS}}}schemeClr") is not None


def test_strip_hardcoded_colors() -> None:
    root = ET.fromstring(
        f'<a:solidFill xmlns:a="{A_NS}"><a:srgbClr val="FF0000"/></a:solidFill>'
    )
    assert strip_hardcoded_colors(root) == 1
    assert root.find(f".//{{{A_NS}}}srgbClr") is None


def test_strip_inline_formatting() -> None:
    root = ET.fromstring(
        f'<a:p xmlns:a="{A_NS}"><a:r><a:rPr><a:latin typeface="X"/></a:rPr></a:r></a:p>'
    )
    assert strip_inline_formatting(root) == 1
    assert root.find(f".//{{{A_NS}}}rPr") is None


def test_set_text_font_family() -> None:
    root = ET.fromstring(f'<a:p xmlns:a="{A_NS}"><a:r><a:rPr/></a:r></a:p>')
    assert set_text_font_family(root, "Aptos") == 1
    latin = root.find(f".//{{{A_NS}}}latin")
    assert latin is not None
    assert latin.attrib.get("typeface") == "Aptos"



================================================
FILE: tests/test_mcp_server.py
================================================
from __future__ import annotations

import json
from contextlib import asynccontextmanager
from pathlib import Path

import conftest
import pytest
from fastmcp import Client

from potxkit.mcp_server import mcp


def _tool_names(tools) -> set[str]:
    names: set[str] = set()
    for tool in tools:
        if isinstance(tool, dict):
            name = tool.get("name")
        else:
            name = getattr(tool, "name", None)
        if name:
            names.add(name)
    return names


@pytest.fixture
async def mcp_client(monkeypatch):
    @asynccontextmanager
    async def _no_docket():
        yield

    monkeypatch.setattr(mcp, "_docket_lifespan", _no_docket)
    async with Client(transport=mcp) as client:
        yield client


async def test_mcp_list_tools_includes_core(mcp_client) -> None:
    tools = await mcp_client.list_tools()
    names = _tool_names(tools)
    for expected in {"info", "validate", "dump_theme", "audit", "dump_tree"}:
        assert expected in names


async def test_mcp_dump_theme_and_validate(tmp_path: Path, mcp_client) -> None:
    src = tmp_path / "sample.potx"
    src.write_bytes(conftest.build_minimal_potx())

    result = await mcp_client.call_tool(
        name="dump_theme", arguments={"path": str(src), "pretty": True}
    )
    payload = json.loads(result.data)
    assert payload.get("dk1") is not None

    result = await mcp_client.call_tool(name="validate", arguments={"path": str(src)})
    assert result.data["ok"] is True


async def test_mcp_set_theme_names(tmp_path: Path, mcp_client) -> None:
    src = tmp_path / "sample.potx"
    out = tmp_path / "named.potx"
    src.write_bytes(conftest.build_minimal_potx())

    result = await mcp_client.call_tool(
        name="set_theme_names",
        arguments={
            "input_path": str(src),
            "output": str(out),
            "theme": "Test Theme",
            "colors": "Test Colors",
            "fonts": "Test Fonts",
        },
    )
    assert out.exists()
    assert result.data == str(out)



================================================
FILE: tests/test_normalize.py
================================================
from __future__ import annotations

import io
import xml.etree.ElementTree as ET
import zipfile

from potxkit.normalize import normalize_slide_colors, parse_slide_numbers
from potxkit.package import OOXMLPackage

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
R_NS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"


def test_parse_slide_numbers() -> None:
    assert parse_slide_numbers("1,3-5,8") == {1, 3, 4, 5, 8}
    assert parse_slide_numbers("5-3") == {3, 4, 5}


def test_normalize_selected_slides() -> None:
    data = _minimal_pptx()
    pkg = OOXMLPackage(data)

    result = normalize_slide_colors(pkg, {"0D0D14": "dk1"}, {1})
    assert result.replacements == 1
    assert result.slides_touched == 1

    slide1 = ET.fromstring(pkg.read_part("ppt/slides/slide1.xml"))
    slide2 = ET.fromstring(pkg.read_part("ppt/slides/slide2.xml"))

    assert slide1.find(f".//{{{A_NS}}}schemeClr") is not None
    assert slide2.find(f".//{{{A_NS}}}srgbClr") is not None


def _minimal_pptx() -> bytes:
    presentation = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:presentation xmlns:p="{P_NS}" xmlns:r="{R_NS}">'
        "<p:sldIdLst>"
        '<p:sldId id="256" r:id="rId1"/>'
        '<p:sldId id="257" r:id="rId2"/>'
        "</p:sldIdLst>"
        "</p:presentation>"
    )

    rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide1.xml"/>'
        '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide2.xml"/>'
        "</Relationships>"
    )

    slide_template = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        f'<p:sld xmlns:p="{P_NS}" xmlns:a="{A_NS}">'
        "<p:cSld>"
        "<p:spTree>"
        "<p:sp>"
        "<p:spPr>"
        '<a:solidFill><a:srgbClr val="{color}"/></a:solidFill>'
        "</p:spPr>"
        "</p:sp>"
        "</p:spTree>"
        "</p:cSld>"
        "</p:sld>"
    )

    out = io.BytesIO()
    with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
        zout.writestr("ppt/presentation.xml", presentation)
        zout.writestr("ppt/_rels/presentation.xml.rels", rels)
        zout.writestr("ppt/slides/slide1.xml", slide_template.format(color="0D0D14"))
        zout.writestr("ppt/slides/slide2.xml", slide_template.format(color="FFFFFF"))
    return out.getvalue()



================================================
FILE: tests/test_prune_layouts.py
================================================
from __future__ import annotations

import io
import xml.etree.ElementTree as ET
import zipfile

from potxkit.layout_ops import prune_unused_layouts
from potxkit.package import OOXMLPackage
from potxkit.rels import parse_relationships


def _build_minimal_deck() -> bytes:
    presentation_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:presentation xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
        '<p:sldIdLst><p:sldId id="256" r:id="rId1"/></p:sldIdLst>'
        "</p:presentation>"
    )
    presentation_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide1.xml"/>'
        "</Relationships>"
    )
    slide_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sld xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">'
        "<p:cSld><p:spTree/></p:cSld>"
        "</p:sld>"
    )
    slide_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout1.xml"/>'
        "</Relationships>"
    )
    master_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sldMaster xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
        "<p:sldLayoutIdLst>"
        '<p:sldLayoutId id="256" r:id="rId1"/>'
        '<p:sldLayoutId id="257" r:id="rId2"/>'
        "</p:sldLayoutIdLst>"
        "</p:sldMaster>"
    )
    master_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout1.xml"/>'
        '<Relationship Id="rId2" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout2.xml"/>'
        "</Relationships>"
    )
    layout_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sldLayout xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">'
        "<p:cSld><p:spTree/></p:cSld>"
        "</p:sldLayout>"
    )
    content_types = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'
        '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>'
        '<Default Extension="xml" ContentType="application/xml"/>'
        '<Override PartName="/ppt/presentation.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>'
        '<Override PartName="/ppt/slides/slide1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slide+xml"/>'
        '<Override PartName="/ppt/slideMasters/slideMaster1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"/>'
        '<Override PartName="/ppt/slideLayouts/slideLayout1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>'
        '<Override PartName="/ppt/slideLayouts/slideLayout2.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>'
        "</Types>"
    )

    out = io.BytesIO()
    with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
        zout.writestr("ppt/presentation.xml", presentation_xml)
        zout.writestr("ppt/_rels/presentation.xml.rels", presentation_rels)
        zout.writestr("ppt/slides/slide1.xml", slide_xml)
        zout.writestr("ppt/slides/_rels/slide1.xml.rels", slide_rels)
        zout.writestr("ppt/slideMasters/slideMaster1.xml", master_xml)
        zout.writestr("ppt/slideMasters/_rels/slideMaster1.xml.rels", master_rels)
        zout.writestr("ppt/slideLayouts/slideLayout1.xml", layout_xml)
        zout.writestr("ppt/slideLayouts/slideLayout2.xml", layout_xml)
        zout.writestr("[Content_Types].xml", content_types)
    return out.getvalue()


def test_prune_unused_layouts_removes_layout_and_master_refs() -> None:
    pkg = OOXMLPackage(_build_minimal_deck())

    result = prune_unused_layouts(pkg)
    assert "ppt/slideLayouts/slideLayout2.xml" in result.removed_layouts
    assert pkg.has_part("ppt/slideLayouts/slideLayout1.xml")
    assert not pkg.has_part("ppt/slideLayouts/slideLayout2.xml")

    rels = parse_relationships(
        pkg.read_part("ppt/slideMasters/_rels/slideMaster1.xml.rels")
    )
    targets = {rel.target for rel in rels}
    assert "../slideLayouts/slideLayout2.xml" not in targets

    master_root = ET.fromstring(pkg.read_part("ppt/slideMasters/slideMaster1.xml"))
    r_ns = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
    layout_ids = [
        node.attrib.get(f"{{{r_ns}}}id")
        for node in master_root.findall(
            ".//{http://schemas.openxmlformats.org/presentationml/2006/main}sldLayoutId"
        )
    ]
    assert "rId2" not in layout_ids

    ct_root = ET.fromstring(pkg.read_part("[Content_Types].xml"))
    overrides = [
        node.attrib.get("PartName")
        for node in ct_root.findall(
            "{http://schemas.openxmlformats.org/package/2006/content-types}Override"
        )
    ]
    assert "/ppt/slideLayouts/slideLayout2.xml" not in overrides



================================================
FILE: tests/test_reindex_layouts.py
================================================
from __future__ import annotations

import io
import xml.etree.ElementTree as ET
import zipfile

from potxkit.layout_ops import reindex_layouts
from potxkit.package import OOXMLPackage
from potxkit.rels import parse_relationships, rels_part_for


def _build_deck_with_gapped_layouts() -> bytes:
    presentation_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:presentation xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
        '<p:sldIdLst><p:sldId id="256" r:id="rId1"/></p:sldIdLst>'
        "</p:presentation>"
    )
    presentation_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide1.xml"/>'
        "</Relationships>"
    )
    slide_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sld xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">'
        "<p:cSld><p:spTree/></p:cSld>"
        "</p:sld>"
    )
    slide_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId7" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout7.xml"/>'
        "</Relationships>"
    )
    master_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sldMaster xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
        "<p:sldLayoutIdLst>"
        '<p:sldLayoutId id="2147483661" r:id="rId1"/>'
        '<p:sldLayoutId id="2147483667" r:id="rId7"/>'
        "</p:sldLayoutIdLst>"
        "</p:sldMaster>"
    )
    master_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout1.xml"/>'
        '<Relationship Id="rId7" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout" '
        'Target="../slideLayouts/slideLayout7.xml"/>'
        '<Relationship Id="rId9" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" '
        'Target="../theme/theme1.xml"/>'
        "</Relationships>"
    )
    layout_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sldLayout xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">'
        "<p:cSld><p:spTree/></p:cSld>"
        "</p:sldLayout>"
    )
    theme_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Test"/>'
    )
    content_types = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'
        '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>'
        '<Default Extension="xml" ContentType="application/xml"/>'
        '<Override PartName="/ppt/presentation.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>'
        '<Override PartName="/ppt/slides/slide1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slide+xml"/>'
        '<Override PartName="/ppt/slideMasters/slideMaster1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"/>'
        '<Override PartName="/ppt/slideLayouts/slideLayout1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>'
        '<Override PartName="/ppt/slideLayouts/slideLayout7.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>'
        '<Override PartName="/ppt/theme/theme1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>'
        "</Types>"
    )

    out = io.BytesIO()
    with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
        zout.writestr("ppt/presentation.xml", presentation_xml)
        zout.writestr("ppt/_rels/presentation.xml.rels", presentation_rels)
        zout.writestr("ppt/slides/slide1.xml", slide_xml)
        zout.writestr("ppt/slides/_rels/slide1.xml.rels", slide_rels)
        zout.writestr("ppt/slideMasters/slideMaster1.xml", master_xml)
        zout.writestr("ppt/slideMasters/_rels/slideMaster1.xml.rels", master_rels)
        zout.writestr("ppt/slideLayouts/slideLayout1.xml", layout_xml)
        zout.writestr("ppt/slideLayouts/slideLayout7.xml", layout_xml)
        zout.writestr("ppt/theme/theme1.xml", theme_xml)
        zout.writestr("[Content_Types].xml", content_types)
    return out.getvalue()


def test_reindex_layouts_updates_layout_names_and_relationships() -> None:
    pkg = OOXMLPackage(_build_deck_with_gapped_layouts())

    result = reindex_layouts(pkg)
    assert result.layout_mapping["ppt/slideLayouts/slideLayout1.xml"] == (
        "ppt/slideLayouts/slideLayout1.xml"
    )
    assert result.layout_mapping["ppt/slideLayouts/slideLayout7.xml"] == (
        "ppt/slideLayouts/slideLayout2.xml"
    )

    assert pkg.has_part("ppt/slideLayouts/slideLayout1.xml")
    assert pkg.has_part("ppt/slideLayouts/slideLayout2.xml")
    assert not pkg.has_part("ppt/slideLayouts/slideLayout7.xml")

    slide_rels_part = rels_part_for("ppt/slides/slide1.xml")
    rels = parse_relationships(pkg.read_part(slide_rels_part))
    targets = {rel.target for rel in rels if rel.type.endswith("/slideLayout")}
    assert "../slideLayouts/slideLayout2.xml" in targets

    master_rels_part = rels_part_for("ppt/slideMasters/slideMaster1.xml")
    master_rels = parse_relationships(pkg.read_part(master_rels_part))
    layout_ids = sorted(
        rel.id for rel in master_rels if rel.type.endswith("/slideLayout")
    )
    assert layout_ids == ["rId1", "rId2"]

    master_root = ET.fromstring(pkg.read_part("ppt/slideMasters/slideMaster1.xml"))
    r_ns = "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
    layout_list_ids = [
        node.attrib.get(f"{{{r_ns}}}id")
        for node in master_root.findall(
            ".//{http://schemas.openxmlformats.org/presentationml/2006/main}sldLayoutId"
        )
    ]
    assert layout_list_ids == ["rId1", "rId2"]

    ct_root = ET.fromstring(pkg.read_part("[Content_Types].xml"))
    overrides = [
        node.attrib.get("PartName")
        for node in ct_root.findall(
            "{http://schemas.openxmlformats.org/package/2006/content-types}Override"
        )
    ]
    assert "/ppt/slideLayouts/slideLayout2.xml" in overrides
    assert "/ppt/slideLayouts/slideLayout7.xml" not in overrides



================================================
FILE: tests/test_sanitize.py
================================================
from __future__ import annotations

import io
import xml.etree.ElementTree as ET
import zipfile

from potxkit.package import OOXMLPackage
from potxkit.sanitize import sanitize_slides


def _build_slide_pkg() -> bytes:
    slide_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:sld xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">'
        "<p:cSld>"
        "<p:bg><p:bgPr><a:effectLst/></p:bgPr></p:bg>"
        "<p:spTree>"
        "<p:sp>"
        "<p:txBody>"
        "<a:bodyPr/>"
        "<a:p><a:r><a:t>Hello</a:t></a:r></a:p>"
        "</p:txBody>"
        "</p:sp>"
        "</p:spTree>"
        "</p:cSld>"
        "</p:sld>"
    )
    presentation_xml = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<p:presentation xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '
        'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'
        '<p:sldIdLst><p:sldId id="256" r:id="rId1"/></p:sldIdLst>'
        "</p:presentation>"
    )
    presentation_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'
        '<Relationship Id="rId1" '
        'Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" '
        'Target="slides/slide1.xml"/>'
        "</Relationships>"
    )
    slide_rels = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"/>'
    )
    content_types = (
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'
        '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'
        '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>'
        '<Default Extension="xml" ContentType="application/xml"/>'
        '<Override PartName="/ppt/presentation.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>'
        '<Override PartName="/ppt/slides/slide1.xml" '
        'ContentType="application/vnd.openxmlformats-officedocument.presentationml.slide+xml"/>'
        "</Types>"
    )

    out = io.BytesIO()
    with zipfile.ZipFile(out, "w", compression=zipfile.ZIP_DEFLATED) as zout:
        zout.writestr("ppt/presentation.xml", presentation_xml)
        zout.writestr("ppt/_rels/presentation.xml.rels", presentation_rels)
        zout.writestr("ppt/slides/slide1.xml", slide_xml)
        zout.writestr("ppt/slides/_rels/slide1.xml.rels", slide_rels)
        zout.writestr("[Content_Types].xml", content_types)
    return out.getvalue()


def test_sanitize_adds_defaults() -> None:
    pkg = OOXMLPackage(_build_slide_pkg())
    result = sanitize_slides(pkg)
    assert result.slides_updated == 1
    assert result.clrmap_added == 1
    assert result.lststyle_added == 1
    assert result.bg_nofill_added == 1

    root = ET.fromstring(pkg.read_part("ppt/slides/slide1.xml"))
    ns = {
        "p": "http://schemas.openxmlformats.org/presentationml/2006/main",
        "a": "http://schemas.openxmlformats.org/drawingml/2006/main",
    }
    assert root.find("p:clrMapOvr", ns) is not None
    assert root.find(".//p:txBody/a:lstStyle", ns) is not None
    assert root.find("p:cSld/p:bg/p:bgPr/a:noFill", ns) is not None



================================================
FILE: tests/test_theme.py
================================================
from __future__ import annotations

from pathlib import Path

from conftest import build_minimal_potx

from potxkit import PotxTemplate
from potxkit.rels import parse_relationships


def test_theme_edit_roundtrip(tmp_path: Path) -> None:
    base = tmp_path / "base.potx"
    base.write_bytes(build_minimal_potx())

    tpl = PotxTemplate.open(str(base))
    tpl.theme.colors.set_accent(1, "#112233")
    tpl.theme.fonts.set_major("Aptos Display")

    out = tmp_path / "out.potx"
    tpl.save(str(out))

    reopened = PotxTemplate.open(str(out))
    assert reopened.theme.colors.get_accent(1) == "#112233"
    assert reopened.theme.fonts.get_major().latin == "Aptos Display"

    report = reopened.validate()
    assert report.ok


def test_save_adds_theme_relationship(tmp_path: Path) -> None:
    base = tmp_path / "base.potx"
    base.write_bytes(build_minimal_potx(include_theme_rel=False))

    tpl = PotxTemplate.open(str(base))
    out = tmp_path / "out.potx"
    tpl.save(str(out))

    rels_path = "ppt/_rels/presentation.xml.rels"
    rels_data = PotxTemplate.open(str(out))._package.read_part(rels_path)
    relationships = parse_relationships(rels_data)
    assert any(
        rel.type
        == "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme"
        for rel in relationships
    )


def test_new_template_roundtrip(tmp_path: Path) -> None:
    tpl = PotxTemplate.new()
    tpl.theme.colors.set_accent(2, "#123456")

    out = tmp_path / "new.potx"
    tpl.save(str(out))

    reopened = PotxTemplate.open(str(out))
    assert reopened.theme.colors.get_accent(2) == "#123456"



================================================
FILE: tests/test_typography.py
================================================
from __future__ import annotations

import xml.etree.ElementTree as ET

from potxkit.typography import (
    detect_placeholder_styles,
    set_layout_text_styles,
    set_master_text_styles,
)

P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"
A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"


def test_detect_placeholder_styles() -> None:
    xml = (
        f'<p:sld xmlns:p="{P_NS}" xmlns:a="{A_NS}">'
        "<p:cSld><p:spTree>"
        '<p:sp><p:nvSpPr><p:nvPr><p:ph type="title"/></p:nvPr></p:nvSpPr>'
        '<p:txBody><a:p><a:r><a:rPr sz="3000" b="1"/></a:r></a:p></p:txBody>'
        "</p:sp>"
        "</p:spTree></p:cSld></p:sld>"
    )
    root = ET.fromstring(xml)
    styles = detect_placeholder_styles(root)
    assert styles["title"]["size_pt"] == 30
    assert styles["title"]["bold"] is True


def test_set_layout_text_styles() -> None:
    xml = (
        f'<p:sldLayout xmlns:p="{P_NS}" xmlns:a="{A_NS}">'
        "<p:cSld><p:spTree>"
        '<p:sp><p:nvSpPr><p:nvPr><p:ph type="title"/></p:nvPr></p:nvSpPr>'
        "<p:txBody><a:bodyPr/><a:lstStyle/></p:txBody></p:sp>"
        "</p:spTree></p:cSld></p:sldLayout>"
    )
    root = ET.fromstring(xml)
    assert set_layout_text_styles(root, 28, True, None, None) > 0
    def_rpr = root.find(f".//{{{A_NS}}}defRPr")
    assert def_rpr is not None
    assert def_rpr.attrib.get("sz") == "2800"
    assert def_rpr.attrib.get("b") == "1"


def test_set_master_text_styles() -> None:
    xml = (
        f'<p:sldMaster xmlns:p="{P_NS}" xmlns:a="{A_NS}">'
        "<p:txStyles><p:titleStyle><a:lvl1pPr/></p:titleStyle></p:txStyles>"
        "</p:sldMaster>"
    )
    root = ET.fromstring(xml)
    assert set_master_text_styles(root, 32, False, None, None) > 0
    def_rpr = root.find(f".//{{{A_NS}}}defRPr")
    assert def_rpr is not None
    assert def_rpr.attrib.get("sz") == "3200"
    assert def_rpr.attrib.get("b") == "0"



================================================
FILE: .githooks/pre-commit
================================================
#!/usr/bin/env bash
set -euo pipefail

blocked=$(git diff --cached --name-only --diff-filter=ACMR | grep -E '\.(pptx|potx)$' || true)
if [[ -n "$blocked" ]]; then
  echo "ERROR: PowerPoint files are not allowed in git:"
  echo "$blocked"
  echo "Remove them from the commit (or move them out of the repo)."
  exit 1
fi

if command -v pre-commit >/dev/null 2>&1 && [[ -f .pre-commit-config.yaml ]]; then
  pre-commit run --hook-stage pre-commit
fi



================================================
FILE: .github/workflows/lint.yml
================================================
name: lint

on:
  push:

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install Poetry
        run: pip install poetry
      - name: Install dependencies
        run: poetry install
      - name: Ruff
        run: poetry run ruff check .
      - name: Black
        run: poetry run black --check .
      - name: Vulture
        run: poetry run vulture src/potxkit --min-confidence 80



================================================
FILE: .github/workflows/publish.yml
================================================
name: Publish to PyPI

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write
  id-token: write

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          python-version: "3.11"
          cache: "pip"
      - name: Build distribution
        run: |
          python -m pip install --upgrade pip
          python -m pip install build
          python -m build
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1

  build-mcpb:
    runs-on: ubuntu-latest
    needs: build-and-publish
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-python@v6
        with:
          python-version: "3.11"
      - uses: actions/setup-node@v5
        with:
          node-version: "20"
      - name: Install mcpb CLI
        run: npm install -g @anthropic-ai/mcpb
      - name: Build MCP bundle
        run: python scripts/build_mcpb.py
      - name: Upload MCP bundle to release
        uses: softprops/action-gh-release@v2
        with:
          files: dist/potxkit.mcpb



================================================
FILE: .github/workflows/tests.yml
================================================
name: tests

on:
  pull_request:
    branches: [main]

jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install Poetry
        run: pip install poetry
      - name: Install dependencies
        run: poetry install
      - name: Run tests
        run: poetry run pytest
